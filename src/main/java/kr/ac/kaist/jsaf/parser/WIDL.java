// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.1,
// (C) 2004-2008 Robert Grimm,
// on Monday, October 24, 2016 at 5:42:29 PM.
// Edit at your own risk.
// ===========================================================================

package kr.ac.kaist.jsaf.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import kr.ac.kaist.jsaf.nodes.*;
import kr.ac.kaist.jsaf.nodes_util.*;
import kr.ac.kaist.jsaf.useful.Useful;
import kr.ac.kaist.jsaf.widl.*;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.jsaf.exceptions.JSAFError.error;

@SuppressWarnings("unchecked")

/**
 * Packrat parser for grammar <code>kr.ac.kaist.jsaf.parser.WIDL</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.1, (C) 2004-2008 Robert Grimm.
 */
public final class WIDL extends ParserBase {

  /** The JAVASCRIPT_RESERVED set. */
  public static final Set<String> JAVASCRIPT_RESERVED = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fDefinitions;
    Result fInterface;
    Result fInterfaceMembers;
    Result fDictionaryMembers;
    Result fDefault;
    Result fExceptionMembers;
    Result fInheritance;
    Result fEnumValues;
    Result fConst;
    Result fConstValue;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fExceptionList;
    Result fScopedNames;
    Result fScopedName;
    Result fScopedName$$Star1;
    Result fAttribute;
    Result fGetterRaises;
    Result fSetterRaises;
    Result fSpecials;
    Result fArgumentList;
    Result fArguments;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fArgument;
    Result fArgumentName;
    Result fExtendedAttributeList;
    Result fExtendedAttributes;
    Result fExtendedAttribute;
    Result fExtendedAttributeFront;
    Result fExtendedAttributeInner;
    Result fOther;
    Result fArgumentNameKeyword;
    Result fType;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fUnionType;
    Result fUnionMemberType;
    Result fUnionMemberTypes;
    Result fNonAnyType;
    Result fPrimitiveType;
    Result fFloatType;
    Result fIntegerType;
    Result fTypeSuffix;
    Result fReturnType;
    Result fIdText;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class WIDLColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public WIDL(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public WIDL(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new WIDLColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.WIDL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWIDL(final int yyStart) throws IOException {
    Result            yyResult;
    List<WDefinition> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEndOfFile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Collections.<WDefinition>emptyList();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDefinitions(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WDefinition> yyVaue = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = yyVaue;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Definitions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDefinitions(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDefinitions) 
      yyColumn.chunk1.fDefinitions = pDefinitions$1(yyStart);
    return yyColumn.chunk1.fDefinitions;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Definitions. */
  private Result pDefinitions$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    List<WDefinition> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pExtendedAttributeList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        List<WEAttribute> v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      List<WEAttribute> a1 = cast(yyOpValue1);

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDefinition(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WDefinition a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDefinitions(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WDefinition> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<WDefinition> a3 = cast(yyOpValue1);

            if (a1 == null && a3 == null) yyValue = Useful.list(a2);
            else if (a1 == null) yyValue = Useful.list(a2, a3);
            else {
              // Rewrite [Callback=FunctionOnly, NoInterfaceObject] interfaces.
              // For example, rewrite the following:
              //
              // [Callback=FunctionOnly, NoInterfaceObject] interface ServiceProviderCreateSuccessCallback {
              //     void onsuccess(in ServiceProvider serviceProvider);
              // };
              //
              // as follows:
              //
              // callback ServiceProviderCreateSuccessCallback = void (ServiceProvider serviceProvider);
              WDefinition def = WIDLFactory.addAttrs(a1, a2);
              if (a1.contains(eaNoInterfaceObject) && a1.contains(eaCallbackFunctionOnly) &&
              a2 instanceof WInterface && ((WInterface)a2).getMembers().size() == 1) {
                WInterface interf = ((WInterface)a2);
                WInterfaceMember member = interf.getMembers().get(0);
                if (member instanceof WOperation) {
                  WOperation op = (WOperation)member;
                  def = WIDLFactory.mkCallback(a2.getInfo().getSpan(), interf.getName(),
                  op.getTyp(), op.getArgs());
                }
              }
              if (a3 == null) yyValue = Useful.list(def);
              else yyValue = Useful.list(def, a3);
            }

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Definition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefinition(final int yyStart) throws IOException {
    Result      yyResult;
    WDefinition yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCallbackOrInterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pPartial(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pDictionary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pException(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pEnum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pTypedef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pImplementsStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModule(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    WDefinition yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmodule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pDefinitions(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WDefinition> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = psemicolon(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyOption1  = yyResult.index;
                        }
                      }

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = WIDLFactory.mkModule(span, a1, a2);

                      return new SemanticValue(yyValue, yyOption1, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.CallbackOrInterface.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallbackOrInterface(final int yyStart) throws IOException {
    Result      yyResult;
    WDefinition yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcallback(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pCallbackRestOrInterface(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WDefinition a1 = yyResult.semanticValue();

          yyValue = WIDLFactory.addCallback(a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pInterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.CallbackRestOrInterface.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallbackRestOrInterface(final int yyStart) 
    throws IOException {

    Result      yyResult;
    WDefinition yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCallbackRest(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pInterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Interface.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInterface(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fInterface) 
      yyColumn.chunk1.fInterface = pInterface$1(yyStart);
    return yyColumn.chunk1.fInterface;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Interface. */
  private Result pInterface$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    WInterface yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdText(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pInheritance(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                WId v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a3.
              WId a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popencurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pInterfaceMembers(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<WInterfaceMember> v$el$3 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$3;
                    }
                  }
                  { // Start scope for a4.
                    List<WInterfaceMember> a4 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pclosecurly(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyOption1  = yyResult.index;

                          yyResult = psemicolon(yyOption1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                          }

                          Span span = createSpan(yyStart,yyCount);
                          if (a3 == null && a4 == null) yyValue = WIDLFactory.mkInterface(span, a2);
                          else if (a3 == null) yyValue = WIDLFactory.mkInterface(span, a2, a4);
                          else if (a4 == null) yyValue = WIDLFactory.mkInterface(span, a2, a3);
                          else yyValue = WIDLFactory.mkInterface(span, a2, a3, a4);
                          if (a1 != null)
                          yyValue = (WInterface)WIDLFactory.addAttrs(a1, yyValue);

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        }
                      }
                    }
                  } // End scope for a4.
                }
              }
            } // End scope for a3.
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Partial.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPartial(final int yyStart) throws IOException {
    Result      yyResult;
    WDefinition yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ppartial(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPartialDefinition(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WDefinition a1 = yyResult.semanticValue();

          yyValue = WIDLFactory.addPartial(a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.PartialDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPartialDefinition(final int yyStart) throws IOException {
    Result      yyResult;
    WDefinition yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPartialInterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPartialDictionary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.PartialInterface.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPartialInterface(final int yyStart) throws IOException {
    Result                 yyResult;
    int                    yyOption1;
    List<WInterfaceMember> yyOpValue1;
    WInterface             yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinterface(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pInterfaceMembers(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WInterfaceMember> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<WInterfaceMember> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psemicolon(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        Span span = createSpan(yyStart,yyCount);
                        if (a2 == null) yyValue = WIDLFactory.mkInterface(span, a1);
                        else yyValue = WIDLFactory.mkInterface(span, a1, a2);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.InterfaceMembers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInterfaceMembers(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fInterfaceMembers) 
      yyColumn.chunk1.fInterfaceMembers = pInterfaceMembers$1(yyStart);
    return yyColumn.chunk1.fInterfaceMembers;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.InterfaceMembers. */
  private Result pInterfaceMembers$1(final int yyStart) throws IOException {
    Result                 yyResult;
    int                    yyOption1;
    Object                 yyOpValue1;
    List<WInterfaceMember> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pExtendedAttributeList(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WEAttribute> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<WEAttribute> a1 = cast(yyOpValue1);

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pInterfaceMember(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WInterfaceMember a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInterfaceMembers(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WInterfaceMember> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<WInterfaceMember> a3 = cast(yyOpValue1);

            if (a1 == null && a3 == null) yyValue = Useful.list(a2);
            else if (a1 == null) yyValue = Useful.list(a2, a3);
            else if (a3 == null) yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2));
            else yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2), a3);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.InterfaceMember.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInterfaceMember(final int yyStart) throws IOException {
    Result           yyResult;
    WInterfaceMember yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConst(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAttributeOrOperation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Dictionary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDictionary(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    Object      yyOpValue1;
    WDictionary yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdictionary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInheritance(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              WId v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            WId a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = popencurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pDictionaryMembers(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<WDictionaryMember> v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
                { // Start scope for a3.
                  List<WDictionaryMember> a3 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = psemicolon(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Span span = createSpan(yyStart,yyCount);
                          if (a2 == null && a3 == null) yyValue = WIDLFactory.mkDictionary(span, a1);
                          else if (a2 == null) yyValue = WIDLFactory.mkDictionary(span, a1, a3);
                          else if (a3 == null) yyValue = WIDLFactory.mkDictionary(span, a1, a2);
                          else yyValue = WIDLFactory.mkDictionary(span, a1, a2, a3);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                } // End scope for a3.
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.DictionaryMembers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDictionaryMembers(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDictionaryMembers) 
      yyColumn.chunk1.fDictionaryMembers = pDictionaryMembers$1(yyStart);
    return yyColumn.chunk1.fDictionaryMembers;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.DictionaryMembers. */
  private Result pDictionaryMembers$1(final int yyStart) throws IOException {
    Result                  yyResult;
    int                     yyOption1;
    Object                  yyOpValue1;
    List<WDictionaryMember> yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pExtendedAttributeList(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WEAttribute> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<WEAttribute> a1 = cast(yyOpValue1);

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDictionaryMember(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WDictionaryMember a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDictionaryMembers(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WDictionaryMember> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<WDictionaryMember> a3 = cast(yyOpValue1);

            if (a1 == null && a3 == null) yyValue = Useful.list(a2);
            else if (a1 == null) yyValue = Useful.list(a2, a3);
            else if (a3 == null) yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2));
            else yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2), a3);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.DictionaryMember.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDictionaryMember(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    WLiteral          yyOpValue1;
    WDictionaryMember yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pDefault(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              WLiteral v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a3.
            WLiteral a3 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = psemicolon(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                if (a3 == null) yyValue = WIDLFactory.mkDictionaryMember(span, a1, a2);
                else yyValue = WIDLFactory.mkDictionaryMember(span, a1, a2, a3);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a3.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.PartialDictionary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPartialDictionary(final int yyStart) throws IOException {
    Result                  yyResult;
    int                     yyOption1;
    List<WDictionaryMember> yyOpValue1;
    WDictionary             yyValue;
    ParseError              yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdictionary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pDictionaryMembers(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WDictionaryMember> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<WDictionaryMember> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = psemicolon(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        Span span = createSpan(yyStart,yyCount);
                        if (a2 == null) yyValue = WIDLFactory.mkDictionary(span, a1);
                        else yyValue = WIDLFactory.mkDictionary(span, a1, a2);

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Default.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefault(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDefault) 
      yyColumn.chunk1.fDefault = pDefault$1(yyStart);
    return yyColumn.chunk1.fDefault;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Default. */
  private Result pDefault$1(final int yyStart) throws IOException {
    Result     yyResult;
    WLiteral   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pequals(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDefaultValue(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.DefaultValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefaultValue(final int yyStart) throws IOException {
    Result     yyResult;
    WLiteral   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConstValue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pstring(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Exception.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pException(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    WException yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexception(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pInheritance(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              WId v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            WId a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = popencurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pExceptionMembers(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<WExceptionMember> v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
                { // Start scope for a3.
                  List<WExceptionMember> a3 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = psemicolon(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Span span = createSpan(yyStart,yyCount);
                          if (a2 == null && a3 == null) yyValue = WIDLFactory.mkException(span, a1);
                          else if (a2 == null) yyValue = WIDLFactory.mkException(span, a1, a3);
                          else if (a3 == null) yyValue = WIDLFactory.mkException(span, a1, a2);
                          else yyValue = WIDLFactory.mkException(span, a1, a2, a3);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                } // End scope for a3.
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExceptionMembers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExceptionMembers(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExceptionMembers) 
      yyColumn.chunk1.fExceptionMembers = pExceptionMembers$1(yyStart);
    return yyColumn.chunk1.fExceptionMembers;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExceptionMembers. */
  private Result pExceptionMembers$1(final int yyStart) throws IOException {
    Result                 yyResult;
    int                    yyOption1;
    Object                 yyOpValue1;
    List<WExceptionMember> yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pExtendedAttributeList(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WEAttribute> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<WEAttribute> a1 = cast(yyOpValue1);

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExceptionMember(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WExceptionMember a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExceptionMembers(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WExceptionMember> v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a3.
            List<WExceptionMember> a3 = cast(yyOpValue1);

            if (a1 == null && a3 == null) yyValue = Useful.list(a2);
            else if (a1 == null) yyValue = Useful.list(a2, a3);
            else if (a3 == null) yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2));
            else yyValue = Useful.list(WIDLFactory.addAttrs(a1, a2), a3);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Inheritance.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInheritance(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fInheritance) 
      yyColumn.chunk1.fInheritance = pInheritance$1(yyStart);
    return yyColumn.chunk1.fInheritance;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Inheritance. */
  private Result pInheritance$1(final int yyStart) throws IOException {
    Result     yyResult;
    WId        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcolon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Enum.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnum(final int yyStart) throws IOException {
    Result     yyResult;
    WEnum      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = penum(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pEnumValueList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WString> a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pclosecurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = psemicolon(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          Span span = createSpan(yyStart,yyCount);
                          yyValue = WIDLFactory.mkEnum(span, a1, a2);

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.EnumValueList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumValueList(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    List<WString> yyOpValue1;
    List<WString> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstring(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WString a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEnumValues(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WString> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<WString> a2 = yyOpValue1;

        if (a2 == null) yyValue = Useful.list(a1);
        else yyValue = Useful.list(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.EnumValues.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumValues(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fEnumValues) 
      yyColumn.chunk1.fEnumValues = pEnumValues$1(yyStart);
    return yyColumn.chunk1.fEnumValues;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.EnumValues. */
  private Result pEnumValues$1(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    List<WString> yyOpValue1;
    List<WString> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomma(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pstring(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WString a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pEnumValues(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WString> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WString> a2 = yyOpValue1;

            if (a2 == null) yyValue = Useful.list(a1);
            else yyValue = Useful.list(a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.CallbackRest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallbackRest(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<WArgument> yyOpValue1;
    WCallback       yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pReturnType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              WType a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pArgumentList(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<WArgument> v$el$1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$1;
                    }
                  }
                  { // Start scope for a3.
                    List<WArgument> a3 = yyOpValue1;

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcloseparen(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount);
                            if (a3 == null) yyValue = WIDLFactory.mkCallback(span, a1, a2);
                            else yyValue = WIDLFactory.mkCallback(span, a1, a2, a3);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Typedef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypedef(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WEAttribute> yyOpValue1;
    WTypedef          yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptypedef(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            WType a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pIdText(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = psemicolon(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Span span = createSpan(yyStart,yyCount);
                    if (a1 == null) yyValue = WIDLFactory.mkTypedef(span, a2, a3);
                    else yyValue = WIDLFactory.mkTypedef(span, a1, a2, a3);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ImplementsStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImplementsStatement(final int yyStart) throws IOException {
    Result               yyResult;
    WImplementsStatement yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pimplements(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIdText(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = psemicolon(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  Span span = createSpan(yyStart,yyCount);
                  yyValue = WIDLFactory.mkImplementsStatement(span, a1, a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Const.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConst(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fConst) 
      yyColumn.chunk1.fConst = pConst$1(yyStart);
    return yyColumn.chunk1.fConst;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Const. */
  private Result pConst$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WEAttribute> yyOpValue1;
    WConst            yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pconst(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pConstType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            WType a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pIdText(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a3 = yyResult.semanticValue();

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pequals(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pConstValue(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        WLiteral a4 = yyResult.semanticValue();

                        yyResult = pw(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount);
                            yyValue = WIDLFactory.mkConst(span, a2, a3, a4);
                            if (a1 != null) yyValue = WIDLFactory.addAttrs(a1, yyValue);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ConstValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstValue(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fConstValue) 
      yyColumn.chunk1.fConstValue = pConstValue$1(yyStart);
    return yyColumn.chunk1.fConstValue;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ConstValue. */
  private Result pConstValue$1(final int yyStart) throws IOException {
    Result     yyResult;
    WLiteral   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFloatLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pinteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = WIDLFactory.mkInteger(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pnullK(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.nullL();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    WBoolean   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptrue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.trueL();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pfalse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.falseL();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.FloatLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    WFloat     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfloatL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = WIDLFactory.mkFloat(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pInfinity(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = WIDLFactory.minusInfinity();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pInfinity(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.infinity();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pNaN(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.nan();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.AttributeOrOperation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeOrOperation(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    Object           yyOpValue1;
    WInterfaceMember yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstringifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pAttribute(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WAttribute a1 = yyResult.semanticValue();

          yyValue = WIDLFactory.addStringifier(a1);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pReturnType(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WType a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pid(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
          }
          { // Start scope for a2.
            String a2 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = popenparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pArgumentList(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<WArgument> v$el$3 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$3;
                  }
                }
                { // Start scope for a3.
                  List<WArgument> a3 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = praises(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExceptionList(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              List<WQId> v$el$4 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$4;
                            }
                          }
                        }
                      }
                      { // Start scope for a4.
                        List<WQId> a4 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount);
                            List<WEAttribute> attrs = new ArrayList<WEAttribute>();
                            attrs.add(WIDLFactory.eaStringifier());
                            List<WQualifier> quals = new ArrayList();
                            if (a3 == null) a3 = Collections.<WArgument>emptyList();
                            if (a2 == null && a4 == null) yyValue = WIDLFactory.mkOperation(span, attrs, quals, a1, a3);
                            else if (a2 == null) yyValue = WIDLFactory.mkOperationExn(span, attrs, quals, a1, a3, a4);
                            else if (a4 == null) yyValue = WIDLFactory.mkOperation(span, attrs, quals, a1, a2, a3);
                            else yyValue = WIDLFactory.mkOperationExn(span, attrs, quals, a1, a2, a3, a4);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      } // End scope for a4.
                    }
                  }
                } // End scope for a3.
              }
            }
          } // End scope for a2.
        }

        // Nested alternative 3.

        yyResult = psemicolon(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          List<WEAttribute> attrs = new ArrayList<WEAttribute>();
          attrs.add(WIDLFactory.eaStringifier());
          List<WQualifier> quals = new ArrayList();
          yyValue = WIDLFactory.mkOperation(span, attrs, quals, WIDLFactory.domstringType(),
          Collections.<WArgument>emptyList());

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pAttribute(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pQualifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WQualifier> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pReturnType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WType a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pid(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
          }
          { // Start scope for a3.
            String a3 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = popenparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pArgumentList(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    List<WArgument> v$el$6 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$6;
                  }
                }
                { // Start scope for a4.
                  List<WArgument> a4 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = praises(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pExceptionList(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              List<WQId> v$el$7 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$7;
                            }
                          }
                        }
                      }
                      { // Start scope for a5.
                        List<WQId> a5 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount);
                            List<WEAttribute> attrs = new ArrayList<WEAttribute>();
                            if (a4 == null) a4 = Collections.<WArgument>emptyList();
                            if (a3 == null && a5 == null) yyValue = WIDLFactory.mkOperation(span, attrs, a1, a2, a4);
                            else if (a3 == null) yyValue = WIDLFactory.mkOperationExn(span, attrs, a1, a2, a4, a5);
                            else if (a5 == null) yyValue = WIDLFactory.mkOperation(span, attrs, a1, a2, a3, a4);
                            else yyValue = WIDLFactory.mkOperationExn(span, attrs, a1, a2, a3, a4, a5);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      } // End scope for a5.
                    }
                  }
                } // End scope for a4.
              }
            }
          } // End scope for a3.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExceptionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExceptionList(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExceptionList) 
      yyColumn.chunk2.fExceptionList = pExceptionList$1(yyStart);
    return yyColumn.chunk2.fExceptionList;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExceptionList. */
  private Result pExceptionList$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<WQId> yyOpValue1;
    List<WQId> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pScopedName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WQId a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pScopedNames(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WQId> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WQId> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcloseparen(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                if (a2 == null) yyValue = Useful.list(a1);
                else yyValue = Useful.list(a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ScopedNames.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pScopedNames(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fScopedNames) 
      yyColumn.chunk2.fScopedNames = pScopedNames$1(yyStart);
    return yyColumn.chunk2.fScopedNames;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ScopedNames. */
  private Result pScopedNames$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    List<WQId> yyOpValue1;
    List<WQId> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomma(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pScopedName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WQId a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pScopedNames(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WQId> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WQId> a2 = yyOpValue1;

            if (a2 == null) yyValue = Useful.list(a1);
            else yyValue = Useful.list(a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ScopedName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pScopedName(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fScopedName) 
      yyColumn.chunk2.fScopedName = pScopedName$1(yyStart);
    return yyColumn.chunk2.fScopedName;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ScopedName. */
  private Result pScopedName$1(final int yyStart) throws IOException {
    Result     yyResult;
    WQId       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pScopedName$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> a2s = yyResult.semanticValue();

        Span span = createSpan(yyStart,yyCount);
        yyValue = WIDLFactory.mkQId(span, Useful.cons(a1, a2s.list()));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.WIDL.ScopedName$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pScopedName$$Star1(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fScopedName$$Star1) 
      yyColumn.chunk2.fScopedName$$Star1 = pScopedName$$Star1$1(yyStart);
    return yyColumn.chunk2.fScopedName$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ScopedName$$Star1. */
  private Result pScopedName$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pscope(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pid(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyResult = pScopedName$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Attribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttribute(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAttribute) 
      yyColumn.chunk2.fAttribute = pAttribute$1(yyStart);
    return yyColumn.chunk2.fAttribute;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Attribute. */
  private Result pAttribute$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    WAttribute yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pinherit(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      String a1 = cast(yyOpValue1);

      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = preadonly(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a2.
        String a2 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pattribute(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExtendedAttributeList(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<WEAttribute> v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
            }
            { // Start scope for a3.
              List<WEAttribute> a3 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  WType a4 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pid(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      String a5 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pAttributeRaises(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<WQId> v$el$4 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$4;
                        }
                      }
                      { // Start scope for a6.
                        List<WQId> a6 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount);
                            List<WEAttribute> attrs = new ArrayList<WEAttribute>();
                            if (a1 != null && a2 != null) {
                              attrs.add(WIDLFactory.eaInherit());
                              attrs.add(WIDLFactory.eaReadonly());
                            } else if (a1 != null) attrs.add(WIDLFactory.eaInherit());
                            else if (a2 != null) attrs.add(WIDLFactory.eaReadonly());
                            if (a6 == null) yyValue = WIDLFactory.mkAttribute(span, attrs, a4, a5);
                            else yyValue = WIDLFactory.mkAttribute(span, attrs, a4, a5, a6);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      } // End scope for a6.
                    }
                  }
                }
              }
            } // End scope for a3.
          }
        }
      } // End scope for a2.
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.AttributeRaises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeRaises(final int yyStart) throws IOException {
    Result     yyResult;
    List<WQId> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pgetraises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pExceptionList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WQId> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = psetraises(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pExceptionList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WQId> a2 = yyResult.semanticValue();

                  yyValue = a1;
                  yyValue.addAll(a2);

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pExceptionList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = psetraises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExceptionList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pGetterRaises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSetterRaises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pGetterRaises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WQId> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pSetterRaises(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WQId> a2 = yyResult.semanticValue();

              yyValue = a1;
              yyValue.addAll(a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pSetterRaises(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WQId> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pGetterRaises(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WQId> a2 = yyResult.semanticValue();

              yyValue = a1;
              yyValue.addAll(a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.GetterRaises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGetterRaises(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fGetterRaises) 
      yyColumn.chunk2.fGetterRaises = pGetterRaises$1(yyStart);
    return yyColumn.chunk2.fGetterRaises;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.GetterRaises. */
  private Result pGetterRaises$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<WQId> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pgetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = praises(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExceptionList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.SetterRaises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSetterRaises(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSetterRaises) 
      yyColumn.chunk2.fSetterRaises = pSetterRaises$1(yyStart);
    return yyColumn.chunk2.fSetterRaises;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.SetterRaises. */
  private Result pSetterRaises$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<WQId> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = psetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = praises(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExceptionList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              yyValue = yyResult.semanticValue();

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Qualifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiers(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    List<WQualifier> yyOpValue1;
    List<WQualifier> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pstatic(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = Useful.list(WIDLFactory.qStatic());

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pSpecials(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WQualifier> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<WQualifier> a1 = yyOpValue1;

      if (a1 == null) yyValue = Collections.<WQualifier>emptyList();
      else yyValue = a1;

      return new SemanticValue(yyValue, yyOption1, yyError);
    } // End scope for a1.
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Specials.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecials(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSpecials) 
      yyColumn.chunk2.fSpecials = pSpecials$1(yyStart);
    return yyColumn.chunk2.fSpecials;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Specials. */
  private Result pSpecials$1(final int yyStart) throws IOException {
    Result           yyResult;
    int              yyOption1;
    List<WQualifier> yyOpValue1;
    List<WQualifier> yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpecial(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WQualifier a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pSpecials(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WQualifier> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<WQualifier> a2 = yyOpValue1;

        Span span = createSpan(yyStart,yyCount);
        if (a2 == null) yyValue = Useful.list(a1);
        else yyValue = Useful.list(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Special.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecial(final int yyStart) throws IOException {
    Result     yyResult;
    WQualifier yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pgetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.qGetter();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = psetter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.qSetter();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pcreator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.qCreator();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pdeleter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.qDeleter();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = plegacycaller(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.qLegacycaller();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ArgumentList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgumentList(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fArgumentList) 
      yyColumn.chunk2.fArgumentList = pArgumentList$1(yyStart);
    return yyColumn.chunk2.fArgumentList;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ArgumentList. */
  private Result pArgumentList$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<WArgument> yyOpValue1;
    List<WArgument> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgument(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WArgument a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WArgument> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<WArgument> a2 = yyOpValue1;

        if (a2 == null) yyValue = Useful.list(a1);
        else yyValue = Useful.list(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fArguments) 
      yyColumn.chunk2.fArguments = pArguments$1(yyStart);
    return yyColumn.chunk2.fArguments;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Arguments. */
  private Result pArguments$1(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyOption1;
    List<WArgument> yyOpValue1;
    List<WArgument> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomma(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArgument(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WArgument a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArguments(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WArgument> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WArgument> a2 = yyOpValue1;

            if (a2 == null) yyValue = Useful.list(a1);
            else yyValue = Useful.list(a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Argument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgument(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fArgument) 
      yyColumn.chunk3.fArgument = pArgument$1(yyStart);
    return yyColumn.chunk3.fArgument;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Argument. */
  private Result pArgument$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WEAttribute> yyOpValue1;
    WArgument         yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pExtendedAttributeList(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WEAttribute> v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      List<WEAttribute> a1 = yyOpValue1;


      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pin(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }
      }

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pOptionalOrRequiredArgument(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WArgument a2 = yyResult.semanticValue();

          if (a1 == null) yyValue = a2;
          else yyValue = WIDLFactory.addAttrs(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * kr.ac.kaist.jsaf.parser.WIDL.OptionalOrRequiredArgument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOptionalOrRequiredArgument(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    WArgument  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = poptional(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            WType a2 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pArgumentName(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pDefault(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    WLiteral v$el$2 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$2;
                  }
                }
                { // Start scope for a4.
                  WLiteral a4 = cast(yyOpValue1);

                  Span span = createSpan(yyStart,yyCount);
                  List<WEAttribute> attrs = Useful.list(WIDLFactory.eaOptional());
                  if (a4 == null) yyValue = WIDLFactory.mkArgument(span, attrs, a2, a3);
                  else yyValue = WIDLFactory.mkArgument(span, attrs, a2, a3, a4);
                  if (a1 != null) yyValue = WIDLFactory.addAttrs(a1, yyValue);

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for a4.
              }
            }
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pExtendedAttributeList(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WEAttribute> v$el$3 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$3;
      }
    }
    { // Start scope for a1.
      List<WEAttribute> a1 = cast(yyOpValue1);

      yyResult = pType(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        WType a2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pellipsis(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$4;
          }
        }
        { // Start scope for a3.
          String a3 = cast(yyOpValue1);

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArgumentName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a4 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              if (a3 == null)
              yyValue = WIDLFactory.mkArgument(span, Collections.<WEAttribute>emptyList(), a2, a4);
              else
              yyValue = WIDLFactory.mkArgument(span, Useful.list(WIDLFactory.eaEllipsis()), a2, a4);
              if (a1 != null) yyValue = WIDLFactory.addAttrs(a1, yyValue);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } // End scope for a3.
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ArgumentName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgumentName(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fArgumentName) 
      yyColumn.chunk3.fArgumentName = pArgumentName$1(yyStart);
    return yyColumn.chunk3.fArgumentName;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ArgumentName. */
  private Result pArgumentName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgumentNameKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pid$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (!JAVASCRIPT_RESERVED.contains(s) &&
          !s.startsWith("__")) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("argument name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExceptionMember.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExceptionMember(final int yyStart) throws IOException {
    Result           yyResult;
    WExceptionMember yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pConst(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExceptionField(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExceptionField.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExceptionField(final int yyStart) throws IOException {
    Result          yyResult;
    WExceptionField yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdText(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = psemicolon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              yyValue = WIDLFactory.mkExceptionField(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendedAttributeList(final int yyStart) 
    throws IOException {

    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExtendedAttributeList) 
      yyColumn.chunk3.fExtendedAttributeList = pExtendedAttributeList$1(yyStart);
    return yyColumn.chunk3.fExtendedAttributeList;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributeList. */
  private Result pExtendedAttributeList$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyOption1;
    List<WEAttribute> yyOpValue1;
    List<WEAttribute> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttribute(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExtendedAttributes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WEAttribute> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WEAttribute> a2 = yyOpValue1;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                if (a2 == null) yyValue = Useful.list(a1);
                else yyValue = Useful.concat(a1, a2);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendedAttributes(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExtendedAttributes) 
      yyColumn.chunk3.fExtendedAttributes = pExtendedAttributes$1(yyStart);
    return yyColumn.chunk3.fExtendedAttributes;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributes. */
  private Result pExtendedAttributes$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WEAttribute> yyOpValue1;
    List<WEAttribute> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcomma(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttribute(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExtendedAttributes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WEAttribute> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WEAttribute> a2 = yyOpValue1;

            Span span = createSpan(yyStart,yyCount);
            if (a2 == null) yyValue = a1;
            else yyValue = Useful.concat(a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendedAttribute(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExtendedAttribute) 
      yyColumn.chunk3.fExtendedAttribute = pExtendedAttribute$1(yyStart);
    return yyColumn.chunk3.fExtendedAttribute;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttribute. */
  private Result pExtendedAttribute$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<WEAttribute> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExtendedAttributeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<WEAttribute> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttribute(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> a2 = yyResult.semanticValue();

          yyValue = Useful.concat(a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pExtendedAttributeFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributeFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendedAttributeFront(final int yyStart) 
    throws IOException {

    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExtendedAttributeFront) 
      yyColumn.chunk3.fExtendedAttributeFront = pExtendedAttributeFront$1(yyStart);
    return yyColumn.chunk3.fExtendedAttributeFront;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributeFront. */
  private Result pExtendedAttributeFront$1(final int yyStart) 
    throws IOException {

    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyOption1;
    Object            yyOpValue1;
    List<WEAttribute> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('C' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('u' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('c' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('o' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('r' == yyC) {
                          yyIndex = yyIndex + 1;

                          final int yyChoice1 = yyIndex;

                          // Nested alternative 1.

                          yyResult = pw(yyChoice1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = popenparen(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyOption1  = yyResult.index;
                              yyOpValue1 = null;

                              yyResult = pw(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pArgumentList(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  List<WArgument> v$el$1 = yyResult.semanticValue();

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = v$el$1;
                                }
                              }
                              { // Start scope for a1.
                                List<WArgument> a1 = cast(yyOpValue1);

                                yyResult = pw(yyOption1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pcloseparen(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    if (a1 == null) a1 = Collections.<WArgument>emptyList();
                                    yyValue = Useful.list(WIDLFactory.mkEAConstructor(a1));

                                    return yyResult.createValue(yyValue, yyError);
                                  }
                                }
                              } // End scope for a1.
                            }
                          }

                          // Nested alternative 2.

                          yyValue = Useful.list(WIDLFactory.mkEAConstructor(Collections.<WArgument>emptyList()));

                          return new SemanticValue(yyValue, yyChoice1, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<WEAttribute>emptyList();
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 3.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<WEAttribute>emptyList();
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 4.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosecurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            if (a1 == null) yyValue = Collections.<WEAttribute>emptyList();
            else yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Alternative 5.

    yyResult = pOther(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WEAttribute a1 = yyResult.semanticValue();

      yyValue = Useful.list(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("extended attribute front expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributeInner.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendedAttributeInner(final int yyStart) 
    throws IOException {

    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExtendedAttributeInner) 
      yyColumn.chunk3.fExtendedAttributeInner = pExtendedAttributeInner$1(yyStart);
    return yyColumn.chunk3.fExtendedAttributeInner;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ExtendedAttributeInner. */
  private Result pExtendedAttributeInner$1(final int yyStart) 
    throws IOException {

    Result            yyResult;
    int               yyOption1;
    List<WEAttribute> yyOpValue1;
    List<WEAttribute> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcloseparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExtendedAttributeInner(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<WEAttribute> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a2.
              List<WEAttribute> a2 = yyOpValue1;

              if (a1 == null && a2 == null) yyValue = Collections.<WEAttribute>emptyList();
              else if (a1 == null) yyValue = a2;
              else if (a2 == null) yyValue = a1;
              else yyValue = Useful.concat(a1, a2);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }
        }
      } // End scope for a1.
    }

    // Alternative 2.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExtendedAttributeInner(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<WEAttribute> v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            }
            { // Start scope for a2.
              List<WEAttribute> a2 = yyOpValue1;

              if (a1 == null && a2 == null) yyValue = Collections.<WEAttribute>emptyList();
              else if (a1 == null) yyValue = a2;
              else if (a2 == null) yyValue = a1;
              else yyValue = Useful.concat(a1, a2);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }
        }
      } // End scope for a1.
    }

    // Alternative 3.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$5 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$5;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = yyOpValue1;

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosecurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pExtendedAttributeInner(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<WEAttribute> v$el$6 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$6;
              }
            }
            { // Start scope for a2.
              List<WEAttribute> a2 = yyOpValue1;

              if (a1 == null && a2 == null) yyValue = Collections.<WEAttribute>emptyList();
              else if (a1 == null) yyValue = a2;
              else if (a2 == null) yyValue = a1;
              else yyValue = Useful.concat(a1, a2);

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a2.
          }
        }
      } // End scope for a1.
    }

    // Alternative 4.

    yyResult = pOther(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WEAttribute a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$7;
        }
      }
      { // Start scope for a2.
        List<WEAttribute> a2 = yyOpValue1;

        Span span = createSpan(yyStart,yyCount);
        if (a2 == null) yyValue = Useful.list(a1);
        else yyValue = Useful.list(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 5.

    yyResult = pcomma(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExtendedAttributeInner(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WEAttribute> v$el$8 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$8;
        }
      }
      { // Start scope for a1.
        List<WEAttribute> a1 = yyOpValue1;

        Span span = createSpan(yyStart,yyCount);
        if (a1 != null) yyValue = Useful.list(a1);
        else yyValue = Collections.<WEAttribute>emptyList();

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Other.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOther(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fOther) 
      yyColumn.chunk3.fOther = pOther$1(yyStart);
    return yyColumn.chunk3.fOther;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Other. */
  private Result pOther$1(final int yyStart) throws IOException {
    int         yyC;
    int         yyIndex;
    Result      yyResult;
    int         yyBase;
    WEAttribute yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pclosesquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = WIDLFactory.eaArray();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'N':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('I' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('n' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('t' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('r' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('f' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('a' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('c' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('O' == yyC) {

                                                      yyC = 
                                                        character(yyIndex);
                                                      if (-1 != yyC) {
                                                        yyIndex = yyIndex + 1;
                                                        if ('b' == yyC) {

                                                          yyC = 
                                                            character(yyIndex);
                                                          if (-1 != yyC) {
                                                            yyIndex = yyIndex + 1;
                                                            if ('j' == yyC) {

                                                              yyC = 
                                                                character(yyIndex);
                                                              if (-1 != yyC) {
                                                                yyIndex = yyIndex + 1;
                                                                if ('e' == yyC) {

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if (-1 != yyC) {
                                                                    yyIndex = yyIndex + 1;
                                                                    if ('c' == yyC) {

                                                                      yyC = 
                                                                        character(yyIndex);
                                                                      if (-1 != yyC) {
                                                                        yyIndex = yyIndex + 1;
                                                                        if ('t' == yyC) {

                                                                          yyValue = eaNoInterfaceObject;

                                                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'C':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('l' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('b' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('c' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('k' == yyC) {

                                      yyResult = pw(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        yyResult = pequals(yyResult.index);
                                        yyError  = yyResult.select(yyError);
                                        if (yyResult.hasValue()) {

                                          yyResult = pw(yyResult.index);
                                          yyError  = yyResult.select(yyError);
                                          if (yyResult.hasValue()) {

                                            yyBase = yyResult.index;
                                            yyC    = character(yyBase);
                                            if ('F' == yyC) {
                                              yyIndex = yyResult.index + 1;

                                              yyC = character(yyIndex);
                                              if ('u' == yyC) {
                                                yyIndex = yyIndex + 1;

                                                yyC = character(yyIndex);
                                                if ('n' == yyC) {
                                                  yyIndex = yyIndex + 1;

                                                  yyC = character(yyIndex);
                                                  if ('c' == yyC) {
                                                    yyIndex = yyIndex + 1;

                                                    yyC = character(yyIndex);
                                                    if ('t' == yyC) {
                                                      yyIndex = yyIndex + 1;

                                                      yyC = 
                                                        character(yyIndex);
                                                      if ('i' == yyC) {
                                                        yyIndex = yyIndex + 1;

                                                        yyC = 
                                                          character(yyIndex);
                                                        if ('o' == yyC) {
                                                          yyIndex = yyIndex + 1;

                                                          yyC = 
                                                            character(yyIndex);
                                                          if ('n' == yyC) {
                                                            yyIndex = yyIndex + 1;

                                                            yyC = 
                                                              character(yyIndex);
                                                            if ('O' == yyC) {
                                                              yyIndex = yyIndex + 1;

                                                              yyC = 
                                                                character(yyIndex);
                                                              if ('n' == yyC) {
                                                                yyIndex = yyIndex + 1;

                                                                yyC = 
                                                                  character(yyIndex);
                                                                if ('l' == yyC) {
                                                                  yyIndex = yyIndex + 1;

                                                                  yyC = 
                                                                    character(yyIndex);
                                                                  if ('y' == yyC) {
                                                                    yyIndex = yyIndex + 1;

                                                                    yyValue = eaCallbackFunctionOnly;

                                                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                                                  } else {
                                                                    yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                                  }
                                                                } else {
                                                                  yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                                }
                                                              } else {
                                                                yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                              }
                                                            } else {
                                                              yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                            }
                                                          } else {
                                                            yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                          }
                                                        } else {
                                                          yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                        }
                                                      } else {
                                                        yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                      }
                                                    } else {
                                                      yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                    }
                                                  } else {
                                                    yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                  }
                                                } else {
                                                  yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                                }
                                              } else {
                                                yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                              }
                                            } else {
                                              yyError = yyError.select("\"FunctionOnly\" expected", yyBase);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyResult = pOther$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = WIDLFactory.mkEAString(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pstring(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WString a1 = yyResult.semanticValue();

      yyValue = WIDLFactory.mkEAString(a1.getStr());

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pquestion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.eaQuestion();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pellipsis(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.eaEllipsis();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = poptional(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.eaOptional();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pArgumentNameKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = WIDLFactory.mkEAArgumentNameKeyword(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = WIDLFactory.mkEAString(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pother(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = WIDLFactory.mkEAString(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("other expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.WIDL.Other$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOther$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinteger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pfloatL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyPredMatched = false;

          yyPredResult = pminus$$Choice1(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = "-";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("other expected", yyStart);
          }
        }
        break;

      case '.':
        {
          yyPredMatched = false;

          yyC = character(yyIndex);
          if ('.' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = ".";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("other expected", yyStart);
          }
        }
        break;

      case ':':
        {
          yyPredMatched = false;

          yyC = character(yyIndex);
          if (':' == yyC) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = ":";

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("other expected", yyStart);
          }
        }
        break;

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = "=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("other expected", yyStart);
      }
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ">";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 7.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'D':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "Date";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("other expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'O':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('M' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('S' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('r' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('i' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('n' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('g' == yyC) {

                                            yyPredMatched = false;

                                            yyPredResult = pidrest(yyIndex);
                                            if (yyPredResult.hasValue()) {

                                              yyPredMatched = true;
                                            }

                                            if (! yyPredMatched) {

                                              yyValue = "DOMString";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            } else {
                                              yyError = yyError.select("other expected", yyStart);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'I':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('f' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('i' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('t' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('y' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "Infinity";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("other expected", yyStart);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'N':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('N' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "NaN";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("other expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      case 'a':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('y' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "any";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("other expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      case 'b':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'o':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('o' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('a' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('n' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "boolean";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("other expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'y':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "byte";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("other expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('b' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('l' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "double";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("other expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('s' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "false";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("other expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'l':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('o' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('a' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "float";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("other expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('n' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('g' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "long";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("other expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('l' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "null";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("other expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'o':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'b':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('j' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('c' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('t' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "object";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("other expected", yyStart);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'c':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "octet";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("other expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'r':
              {
                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = "or";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("other expected", yyStart);
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('q' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('u' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('n' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('c' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('e' == yyC) {

                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "sequence";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("other expected", yyStart);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'h':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('o' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('r' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "short";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("other expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "true";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("other expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'u':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('s' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('i' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('g' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('n' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('e' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('d' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "unsigned";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("other expected", yyStart);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'v':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('o' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('i' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('d' == yyC) {

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = "void";

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("other expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("other expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ArgumentNameKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgumentNameKeyword(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fArgumentNameKeyword) 
      yyColumn.chunk3.fArgumentNameKeyword = pArgumentNameKeyword$1(yyStart);
    return yyColumn.chunk3.fArgumentNameKeyword;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ArgumentNameKeyword. */
  private Result pArgumentNameKeyword$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'a':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('t' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('r' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('i' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('b' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('u' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('t' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('e' == yyC) {

                                          yyPredMatched = false;

                                          yyPredResult = pidrest(yyIndex);
                                          if (yyPredResult.hasValue()) {

                                            yyPredMatched = true;
                                          }

                                          if (! yyPredMatched) {

                                            yyValue = "attribute";

                                            return new SemanticValue(yyValue, yyIndex, yyError);
                                          } else {
                                            yyError = yyError.select("argument name keyword expected", yyStart);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'c':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'a':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('b' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('a' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('c' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('k' == yyC) {

                                        yyPredMatched = false;

                                        yyPredResult = pidrest(yyIndex);
                                        if (yyPredResult.hasValue()) {

                                          yyPredMatched = true;
                                        }

                                        if (! yyPredMatched) {

                                          yyValue = "callback";

                                          return new SemanticValue(yyValue, yyIndex, yyError);
                                        } else {
                                          yyError = yyError.select("argument name keyword expected", yyStart);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'o':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('n' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('s' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = "const";

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("argument name keyword expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'r':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('e' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('a' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('o' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('r' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "creator";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("argument name keyword expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'd':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('t' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('e' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('r' == yyC) {

                                    yyPredMatched = false;

                                    yyPredResult = pidrest(yyIndex);
                                    if (yyPredResult.hasValue()) {

                                      yyPredMatched = true;
                                    }

                                    if (! yyPredMatched) {

                                      yyValue = "deleter";

                                      return new SemanticValue(yyValue, yyIndex, yyError);
                                    } else {
                                      yyError = yyError.select("argument name keyword expected", yyStart);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'i':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('c' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('t' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('i' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('o' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('n' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('a' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('r' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('y' == yyC) {

                                                yyPredMatched = false;

                                                yyPredResult = 
                                                  pidrest(yyIndex);
                                                if (yyPredResult.hasValue()) {

                                                  yyPredMatched = true;
                                                }

                                                if (! yyPredMatched) {

                                                  yyValue = "dictionary";

                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                } else {
                                                  yyError = yyError.select("argument name keyword expected", yyStart);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'n':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('u' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('m' == yyC) {

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "enum";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("argument name keyword expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'x':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('c' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('e' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('p' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('t' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('i' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('o' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('n' == yyC) {

                                            yyPredMatched = false;

                                            yyPredResult = pidrest(yyIndex);
                                            if (yyPredResult.hasValue()) {

                                              yyPredMatched = true;
                                            }

                                            if (! yyPredMatched) {

                                              yyValue = "exception";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            } else {
                                              yyError = yyError.select("argument name keyword expected", yyStart);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'g':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('t' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('r' == yyC) {

                              yyPredMatched = false;

                              yyPredResult = pidrest(yyIndex);
                              if (yyPredResult.hasValue()) {

                                yyPredMatched = true;
                              }

                              if (! yyPredMatched) {

                                yyValue = "getter";

                                return new SemanticValue(yyValue, yyIndex, yyError);
                              } else {
                                yyError = yyError.select("argument name keyword expected", yyStart);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'i':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'm':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('p' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('l' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('m' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('e' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('n' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('t' == yyC) {

                                            yyC = character(yyIndex);
                                            if (-1 != yyC) {
                                              yyIndex = yyIndex + 1;
                                              if ('s' == yyC) {

                                                yyPredMatched = false;

                                                yyPredResult = 
                                                  pidrest(yyIndex);
                                                if (yyPredResult.hasValue()) {

                                                  yyPredMatched = true;
                                                }

                                                if (! yyPredMatched) {

                                                  yyValue = "implements";

                                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                                } else {
                                                  yyError = yyError.select("argument name keyword expected", yyStart);
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 'n':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'h':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('r' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('i' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('t' == yyC) {

                                      yyPredMatched = false;

                                      yyPredResult = pidrest(yyIndex);
                                      if (yyPredResult.hasValue()) {

                                        yyPredMatched = true;
                                      }

                                      if (! yyPredMatched) {

                                        yyValue = "inherit";

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      } else {
                                        yyError = yyError.select("argument name keyword expected", yyStart);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 't':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('r' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('f' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('a' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('c' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('e' == yyC) {

                                              yyPredMatched = false;

                                              yyPredResult = pidrest(yyIndex);
                                              if (yyPredResult.hasValue()) {

                                                yyPredMatched = true;
                                              }

                                              if (! yyPredMatched) {

                                                yyValue = "interface";

                                                return new SemanticValue(yyValue, yyIndex, yyError);
                                              } else {
                                                yyError = yyError.select("argument name keyword expected", yyStart);
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('e' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('g' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('c' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('y' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('c' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('a' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('l' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('l' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('r' == yyC) {

                                                      yyPredMatched = false;

                                                      yyPredResult = 
                                                        pidrest(yyIndex);
                                                      if (yyPredResult.hasValue()) {

                                                        yyPredMatched = true;
                                                      }

                                                      if (! yyPredMatched) {

                                                        yyValue = "legacycaller";

                                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                                      } else {
                                                        yyError = yyError.select("argument name keyword expected", yyStart);
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'p':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('t' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('i' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('a' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('l' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "partial";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("argument name keyword expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 's':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'e':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('t' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('e' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('r' == yyC) {

                                yyPredMatched = false;

                                yyPredResult = pidrest(yyIndex);
                                if (yyPredResult.hasValue()) {

                                  yyPredMatched = true;
                                }

                                if (! yyPredMatched) {

                                  yyValue = "setter";

                                  return new SemanticValue(yyValue, yyIndex, yyError);
                                } else {
                                  yyError = yyError.select("argument name keyword expected", yyStart);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              break;

            case 't':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case 'a':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('t' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('i' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('c' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "static";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("argument name keyword expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  case 'r':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('i' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('n' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('g' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('i' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('f' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('i' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('r' == yyC) {

                                                      yyPredMatched = false;

                                                      yyPredResult = 
                                                        pidrest(yyIndex);
                                                      if (yyPredResult.hasValue()) {

                                                        yyPredMatched = true;
                                                      }

                                                      if (! yyPredMatched) {

                                                        yyValue = "stringifier";

                                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                                      } else {
                                                        yyError = yyError.select("argument name keyword expected", yyStart);
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('y' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('p' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('d' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('e' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('f' == yyC) {

                                  yyPredMatched = false;

                                  yyPredResult = pidrest(yyIndex);
                                  if (yyPredResult.hasValue()) {

                                    yyPredMatched = true;
                                  }

                                  if (! yyPredMatched) {

                                    yyValue = "typedef";

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  } else {
                                    yyError = yyError.select("argument name keyword expected", yyStart);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'u':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('n' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('s' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('t' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('r' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if ('i' == yyC) {

                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;
                                        if ('c' == yyC) {

                                          yyC = character(yyIndex);
                                          if (-1 != yyC) {
                                            yyIndex = yyIndex + 1;
                                            if ('t' == yyC) {

                                              yyC = character(yyIndex);
                                              if (-1 != yyC) {
                                                yyIndex = yyIndex + 1;
                                                if ('e' == yyC) {

                                                  yyC = character(yyIndex);
                                                  if (-1 != yyC) {
                                                    yyIndex = yyIndex + 1;
                                                    if ('d' == yyC) {

                                                      yyPredMatched = false;

                                                      yyPredResult = 
                                                        pidrest(yyIndex);
                                                      if (yyPredResult.hasValue()) {

                                                        yyPredMatched = true;
                                                      }

                                                      if (! yyPredMatched) {

                                                        yyValue = "unrestricted";

                                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                                      } else {
                                                        yyError = yyError.select("argument name keyword expected", yyStart);
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("argument name keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fType) 
      yyColumn.chunk3.fType = pType$1(yyStart);
    return yyColumn.chunk3.fType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSingleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnionType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.SingleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleType(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WTypeSuffix> yyOpValue1;
    WType             yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNonAnyType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pany(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popensquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypeSuffix(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WTypeSuffix> v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
              }
              { // Start scope for a1.
                List<WTypeSuffix> a1 = yyOpValue1;

                Span span = createSpan(yyStart,yyCount);
                if (a1 == null) yyValue = WIDLFactory.anyArrayType();
                else yyValue = WIDLFactory.mkAnyArrayType(span, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a1.
            }
          }
        }
      }

      // Nested alternative 2.

      yyValue = WIDLFactory.anyType();

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.UnionType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnionType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fUnionType) 
      yyColumn.chunk4.fUnionType = pUnionType$1(yyStart);
    return yyColumn.chunk4.fUnionType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.UnionType. */
  private Result pUnionType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    WUnionType yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnionMemberType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WType a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = por(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pUnionMemberType(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  WType a2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pUnionMemberTypes(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<WType> v$el$1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$1;
                    }
                  }
                  { // Start scope for a3.
                    List<WType> a3 = cast(yyOpValue1);

                    yyResult = pw(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pcloseparen(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pTypeSuffix(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {
                            List<WTypeSuffix> v$el$2 = yyResult.semanticValue();

                            yyOption1  = yyResult.index;
                            yyOpValue1 = v$el$2;
                          }
                        }
                        { // Start scope for a4.
                          List<WTypeSuffix> a4 = cast(yyOpValue1);

                          Span span = createSpan(yyStart,yyCount);
                          List<WType> types = new ArrayList<WType>();
                          if (a3 == null) types = Useful.list(a1, a2);
                          else types = Useful.concat(Useful.list(a1, a2), a3);
                          if (a4 == null) yyValue = WIDLFactory.mkUnionType(span, types);
                          else yyValue = WIDLFactory.mkUnionType(span, types, a4);

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for a4.
                      }
                    }
                  } // End scope for a3.
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.UnionMemberType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnionMemberType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fUnionMemberType) 
      yyColumn.chunk4.fUnionMemberType = pUnionMemberType$1(yyStart);
    return yyColumn.chunk4.fUnionMemberType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.UnionMemberType. */
  private Result pUnionMemberType$1(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyOption1;
    List<WTypeSuffix> yyOpValue1;
    WType             yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNonAnyType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnionType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pany(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popensquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypeSuffix(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WTypeSuffix> v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
              }
              { // Start scope for a1.
                List<WTypeSuffix> a1 = yyOpValue1;

                Span span = createSpan(yyStart,yyCount);
                if (a1 == null) yyValue = WIDLFactory.anyArrayType();
                else yyValue = WIDLFactory.mkAnyArrayType(span, a1);

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for a1.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.UnionMemberTypes.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnionMemberTypes(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fUnionMemberTypes) 
      yyColumn.chunk4.fUnionMemberTypes = pUnionMemberTypes$1(yyStart);
    return yyColumn.chunk4.fUnionMemberTypes;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.UnionMemberTypes. */
  private Result pUnionMemberTypes$1(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyOption1;
    List<WType> yyOpValue1;
    List<WType> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = por(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnionMemberType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WType a1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pUnionMemberTypes(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WType> v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a2.
            List<WType> a2 = yyOpValue1;

            Span span = createSpan(yyStart,yyCount);
            if (a2 == null) yyValue = Useful.list(a1);
            else yyValue = Useful.list(a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a2.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.NonAnyType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonAnyType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fNonAnyType) 
      yyColumn.chunk4.fNonAnyType = pNonAnyType$1(yyStart);
    return yyColumn.chunk4.fNonAnyType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.NonAnyType. */
  private Result pNonAnyType$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WType a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypeSuffix(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WTypeSuffix> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a2.
        List<WTypeSuffix> a2 = cast(yyOpValue1);

        if (a2 == null) yyValue = a1;
        else yyValue = WIDLFactory.addTypeSuffix(a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pDOMString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypeSuffix(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WTypeSuffix> v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      }
      { // Start scope for a1.
        List<WTypeSuffix> a1 = cast(yyOpValue1);

        if (a1 == null) yyValue = WIDLFactory.domstringType();
        else yyValue = WIDLFactory.addTypeSuffix(WIDLFactory.domstringType(), a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a1.
    }

    // Alternative 3.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypeSuffix(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WTypeSuffix> v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
      }
      { // Start scope for a2.
        List<WTypeSuffix> a2 = cast(yyOpValue1);

        Span span = createSpan(yyStart,yyCount);
        if (a2 == null) yyValue = WIDLFactory.mkNamedType(span, a1);
        else yyValue = WIDLFactory.mkNamedType(span, a1, a2);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Alternative 4.

    yyResult = psequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('<' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              WType a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase = yyResult.index;
                yyC    = character(yyBase);
                if ('>' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyOption1  = yyIndex;
                  yyOpValue1 = null;

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pquestion(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      String v$el$4 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$4;
                    }
                  }
                  { // Start scope for a2.
                    String a2 = cast(yyOpValue1);

                    Span span = createSpan(yyStart,yyCount);
                    List<WTypeSuffix> suffix = new ArrayList<WTypeSuffix>();
                    if (a2 == null) yyValue = WIDLFactory.mkSequenceType(span, a1, suffix);
                    else {
                      suffix.add(WIDLFactory.tsQuestion());
                      yyValue = WIDLFactory.mkSequenceType(span, a1, suffix);
                    }

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for a2.
                } else {
                  yyError = yyError.select("\">\" expected", yyBase);
                }
              }
            }
          }
        } else {
          yyError = yyError.select("\"<\" expected", yyBase);
        }
      }
    }

    // Alternative 5.

    yyResult = pobject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypeSuffix(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WTypeSuffix> v$el$5 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$5;
        }
      }
      { // Start scope for a1.
        List<WTypeSuffix> a1 = cast(yyOpValue1);

        if (a1 == null) yyValue = WIDLFactory.objectType();
        else yyValue = WIDLFactory.addTypeSuffix(WIDLFactory.objectType(), a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a1.
    }

    // Alternative 6.

    yyResult = pDate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pTypeSuffix(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<WTypeSuffix> v$el$6 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$6;
        }
      }
      { // Start scope for a1.
        List<WTypeSuffix> a1 = cast(yyOpValue1);

        if (a1 == null) yyValue = WIDLFactory.dateType();
        else yyValue = WIDLFactory.addTypeSuffix(WIDLFactory.dateType(), a1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ConstType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstType(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WType a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pquestion(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = WIDLFactory.questionType(a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pPrimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pquestion(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          Span span = createSpan(yyStart,yyCount);
          yyValue = WIDLFactory.mkNamedType(span, a1, WIDLFactory.tsQuestion());

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = WIDLFactory.mkNamedType(span, a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.PrimitiveType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimitiveType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fPrimitiveType) 
      yyColumn.chunk4.fPrimitiveType = pPrimitiveType$1(yyStart);
    return yyColumn.chunk4.fPrimitiveType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.PrimitiveType. */
  private Result pPrimitiveType$1(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnsignedIntegerType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnrestrictedFloatType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pboolean(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.booleanType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pbyte(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.byteType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = poctet(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.octetType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.UnrestrictedFloatType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnrestrictedFloatType(final int yyStart) 
    throws IOException {

    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = punrestricted(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pFloatType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WType a1 = yyResult.semanticValue();

          yyValue = WIDLFactory.unrestricted(a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pFloatType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.FloatType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fFloatType) 
      yyColumn.chunk4.fFloatType = pFloatType$1(yyStart);
    return yyColumn.chunk4.fFloatType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.FloatType. */
  private Result pFloatType$1(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfloatK(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.floatType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pdouble(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.doubleType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.UnsignedIntegerType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnsignedIntegerType(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = punsigned(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIntegerType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          WType a1 = yyResult.semanticValue();

          yyValue = WIDLFactory.unsinged(a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pIntegerType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.IntegerType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIntegerType) 
      yyColumn.chunk4.fIntegerType = pIntegerType$1(yyStart);
    return yyColumn.chunk4.fIntegerType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.IntegerType. */
  private Result pIntegerType$1(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pshort(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.shortType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = plong(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = plong(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = WIDLFactory.longLongType();

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyValue = WIDLFactory.longType();

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.TypeSuffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeSuffix(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTypeSuffix) 
      yyColumn.chunk4.fTypeSuffix = pTypeSuffix$1(yyStart);
    return yyColumn.chunk4.fTypeSuffix;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.TypeSuffix. */
  private Result pTypeSuffix$1(final int yyStart) throws IOException {
    Result            yyResult;
    List<WTypeSuffix> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pclosesquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pTypeSuffix(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<WTypeSuffix> a1 = yyResult.semanticValue();

              yyValue = Useful.list(WIDLFactory.tsArray(), a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = Useful.list(WIDLFactory.tsArray());

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pquestion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popensquare(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pclosesquare(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              final int yyChoice2 = yyResult.index;

              // Nested alternative 1.

              yyResult = pw(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pTypeSuffix(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<WTypeSuffix> a1 = yyResult.semanticValue();

                  yyValue = Useful.concat(Useful.list(WIDLFactory.tsQuestion(), WIDLFactory.tsArray()),
                  a1);

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 2.

              yyValue = Useful.list(WIDLFactory.tsQuestion(), WIDLFactory.tsArray());

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      yyValue = Useful.list(WIDLFactory.tsQuestion());

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ReturnType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReturnType(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fReturnType) 
      yyColumn.chunk4.fReturnType = pReturnType$1(yyStart);
    return yyColumn.chunk4.fReturnType;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.ReturnType. */
  private Result pReturnType$1(final int yyStart) throws IOException {
    Result     yyResult;
    WType      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pvoidK(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = WIDLFactory.voidType();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (!JAVASCRIPT_RESERVED.contains(s) &&
          !s.startsWith("__")) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.WIDL.id$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyResult = pidrest(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.IdText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdText(final int yyStart) throws IOException {
    WIDLColumn yyColumn = (WIDLColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIdText) 
      yyColumn.chunk4.fIdText = pIdText$1(yyStart);
    return yyColumn.chunk4.fIdText;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.WIDL.IdText. */
  private Result pIdText$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeUtil.dropAnySingleLeadingUnderscore(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    Result     yyResult;
    WId        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = WIDLFactory.mkId(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.integer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinteger(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pminus(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      String a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('0' == yyC) {
        yyIndex = yyChoice1 + 1;

        final int yyChoice2 = yyIndex;

        // Nested alternative 1.

        yyC = character(yyChoice2);
        if (-1 != yyC) {
          yyIndex = yyChoice2 + 1;

          switch (yyC) {
          case 'X':
          case 'x':
            {
              yyResult = pHexaDigits(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String a2 = yyResult.semanticValue();

                String sign = "";
                if (a1 != null) sign = "-";
                yyValue = sign+"0x"+a2;

                return yyResult.createValue(yyValue, yyError);
              }
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyOption1  = yyChoice2;
        yyOpValue1 = null;

        yyResult = pOctalDigits(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for a2.
          String a2 = yyOpValue1;

          String sign = "";
          if (a1 != null) sign = "-";
          if (a2 == null) yyValue = sign+"0";
          else yyValue = sign+"0"+a2;

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      } else {
        yyError = yyError.select("\"0\" expected", yyBase);
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        char a2 = (char)yyC;

        if (('1' <= a2) && (a2 <= '9')) {

          yyOption1  = yyIndex;
          yyOpValue1 = null;

          yyResult = pDecimalDigits(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for a3.
            String a3 = yyOpValue1;

            String sign = "";
            if (a1 != null) sign = "-";
            if (a3 == null) yyValue = sign+a2;
            else yyValue = sign+a2+a3;

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for a3.
        }
      }
    } // End scope for a1.

    // Done.
    yyError = yyError.select("integer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.floatL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfloatL(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pminus(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for a1.
      String a1 = yyOpValue1;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyResult = pfloatfront(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        final int yyChoice2 = yyResult.index;

        // Nested alternative 1.

        yyResult = pfloatback(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          String sign = "";
          if (a1 != null) sign = "-";
          yyValue = sign+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        String sign = "";
        if (a1 != null) sign = "-";
        yyValue = sign+a2;

        return new SemanticValue(yyValue, yyChoice2, yyError);
      }

      // Nested alternative 2.

      yyResult = pDecimalDigits(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pfloatback(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          String sign = "";
          if (a1 != null) sign = "-";
          yyValue = sign+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.floatfront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfloatfront(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pDecimalDigits(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for a2.
          String a2 = yyOpValue1;

          if (a2 == null) yyValue = a1;
          else yyValue = a1+"."+a2;

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pDecimalDigits(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$2;
    }
    { // Start scope for a1.
      String a1 = yyOpValue1;

      yyResult = pdot(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDecimalDigits(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          if (a1 == null) yyValue = "0."+a2;
          else yyValue = a1+"."+a2;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.floatback.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfloatback(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;
          yyOpValue1 = null;

          yyResult = pfloatback$$Choice1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for a1.
            String a1 = yyOpValue1;

            yyResult = pDecimalDigits(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a2 = yyResult.semanticValue();

              if (a1 == null) yyValue = "e"+a2;
              else            yyValue = "e"+a1+a2;

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for a1.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("floatback expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.WIDL.floatback$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfloatback$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("floatback expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.DecimalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.HexaDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexaDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("hexa digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.OctalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("octal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.string.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstring(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    WString      yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pStringChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a1s.
        Pair<String> a1s = yyRepValue1.reverse();

        yyC = character(yyRepetition1);
        if ('\"' == yyC) {
          yyIndex = yyRepetition1 + 1;

          String str = "";
          for (String c : (List<String>)a1s.list()) str = str.concat(c);
          yyValue = WIDLFactory.mkString(createSpan(yyStart,yyCount+1), str);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      } // End scope for a1s.
    }

    // Done.
    yyError = yyError.select("string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.StringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ('\"' != a1) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.other.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pother(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNotOther(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("other expected", yyStart);
    }

    // Done.
    yyError = yyError.select("other expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.NotOther.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNotOther(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('\t' <= yyC) && (yyC <= '\n')) ||
          ('\r' == yyC) ||
          (('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ')':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("not other expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.MultiLineCommentChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('/' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.MultiLineCommentWLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentWLB(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentCharNoLB(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyResult = pLineTerminator(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pMultiLineCommentCharWLB(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<String>(v$el$2, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a3s.
              Pair<String> a3s = yyRepValue1.reverse();

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if ('*' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyC = character(yyIndex);
                if ('/' == yyC) {
                  yyIndex = yyIndex + 1;

                  StringBuilder buf = new StringBuilder();
                  buf.append("/*");
                  for (String s : a1s.list()) buf.append(s);
                  buf.append(a2);
                  for (String s : a3s.list()) buf.append(s);
                  buf.append("*/");
                  yyValue = buf.toString();

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("\"*/\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"*/\" expected", yyBase);
              }
            } // End scope for a3s.
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("multi line comment w l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.MultiLineCommentCharWLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharWLB(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('/' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char w l b expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char w l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.MultiLineCommentNoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentNoLB(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentCharNoLB(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              StringBuilder buf = new StringBuilder();
              buf.append("/*");
              for (String s : a1s.list()) buf.append(s);
              buf.append("*/");
              yyValue = buf.toString();

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*/\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*/\" expected", yyBase);
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("multi line comment no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.MultiLineCommentCharNoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharNoLB(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pMultiLineCommentCharNoLB$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char no l b expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.WIDL.MultiLineCommentCharNoLB$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharNoLB$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = pLineTerminator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("multi line comment char no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.SingleLineCommentChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleLineCommentChar(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pLineTerminator(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("single line comment char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single line comment char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.LineTerminator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLineTerminator$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = ""+a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pMultiLineCommentWLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.WIDL.LineTerminator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminator$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2028' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('\u2029' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.LineTerminatorSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminatorSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLineTerminatorSequence$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = ""+a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('\n' == yyC) {
        yyIndex = yyChoice1 + 1;
        char a2 = (char)yyC;

        yyValue = ""+a1+a2;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }

      // Nested alternative 2.

      yyPredMatched = false;

      yyC = character(yyChoice1);
      if ('\n' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = ""+a1;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("line terminator sequence expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pMultiLineCommentWLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.WIDL.LineTerminatorSequence$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminatorSequence$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\u2028' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2029' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Void         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\u000b' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u00a0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\ufeff':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('/' == yyC) {

              yyRepetition1 = yyIndex;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pSingleLineCommentChar(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  String v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for a1s.
                Pair<String> a1s = yyRepValue1.reverse();

                StringBuilder buf = new StringBuilder();
                buf.append("/*");
                for (String s : a1s.list()) buf.append(s);
                buf.append("*/");

                yyValue = null;

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for a1s.
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 6.

    yyResult = pMultiLineCommentNoLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pLineTerminatorSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentChar(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              StringBuilder buf = new StringBuilder();
              buf.append("/*");
              for (String s : a1s.list()) buf.append(s);
              buf.append("*/");

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*/\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*/\" expected", yyBase);
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("whitespace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('\u001a' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    } else {
      yyError = yyError.select("\"\\u001a\" expected", yyBase);
    }

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if (-1 != yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("end of file expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.openparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("openparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.closeparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closeparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popensquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.closesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.scope.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pscope(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (':' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("scope expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (':' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("colon expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.equals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequals(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("equals expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("equals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.minus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pminus$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = "-";

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("minus expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.WIDL.minus$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.ellipsis.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pellipsis(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('.' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('.' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = "...";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ellipsis expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('.' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("dot expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.question.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pquestion(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "?";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("question expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.DOMString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDOMString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('D' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('O' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('M' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('S' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('g' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("d o m string expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("d o m string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Date.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDate(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('D' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("date expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("date expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.Infinity.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfinity(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('I' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("infinity expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("infinity expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.NaN.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNaN(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('N' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('N' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("na n expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("na n expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.any.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pany(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("any expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("any expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.boolean.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pboolean(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('n' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("boolean expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("boolean expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.byte.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbyte(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("byte expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("byte expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.double.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdouble(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('b' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("double expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("double expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.false.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfalse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("false expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("false expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.floatK.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfloatK(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("float k expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("float k expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.long.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plong(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('g' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("long expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("long expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.nullK.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnullK(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("null k expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("null k expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.object.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pobject(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('b' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('j' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("object expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("object expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.octet.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result poctet(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('c' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("octet expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("octet expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.optional.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result poptional(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('p' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('l' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("optional expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("optional expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.or.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result por(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('o' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("or expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("or expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.readonly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result preadonly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('y' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = "readonly";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("readonly expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("readonly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.sequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('q' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("sequence expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.short.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pshort(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("short expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("short expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.true.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptrue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("true expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("true expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.unsigned.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punsigned(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('g' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('d' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("unsigned expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unsigned expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.voidK.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvoidK(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("void k expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("void k expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.attribute.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pattribute(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('b' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('u' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('t' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('e' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("attribute expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("attribute expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.callback.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcallback(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('b' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('k' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("callback expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("callback expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.const.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pconst(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("const expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("const expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.creator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcreator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('o' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("creator expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("creator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.deleter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdeleter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("deleter expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("deleter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.dictionary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdictionary(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('o' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('n' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('a' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('r' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('y' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("dictionary expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("dictionary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.enum.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result penum(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("enum expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("enum expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.exception.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexception(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('o' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('n' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("exception expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("exception expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.getter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("getter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("getter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.implements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimplements(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('m' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('s' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = null;

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("implements expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("implements expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.inherit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinherit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('h' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = "inherit";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("inherit expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("inherit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.interface.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinterface(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('f' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('a' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('c' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('e' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("interface expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("interface expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.legacycaller.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result plegacycaller(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('l' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('g' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('y' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('a' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('l' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('l' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('r' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("legacycaller expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("legacycaller expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.partial.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ppartial(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('p' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('l' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("partial expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("partial expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.setter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psetter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("setter expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("setter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.static.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstatic(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('a' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('c' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("static expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("static expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.stringifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstringifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('t' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('i' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('n' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('f' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('e' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('r' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyPredMatched = false;

                          yyPredResult = pidrest(yyIndex);
                          if (yyPredResult.hasValue()) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          } else {
                            yyError = yyError.select("stringifier expected", yyStart);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("stringifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.typedef.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptypedef(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('d' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('f' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("typedef expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("typedef expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.unrestricted.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result punrestricted(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('r' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('i' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('c' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('t' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('e' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('d' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyPredMatched = false;

                            yyPredResult = pidrest(yyIndex);
                            if (yyPredResult.hasValue()) {

                              yyPredMatched = true;
                            }

                            if (! yyPredMatched) {

                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            } else {
                              yyError = yyError.select("unrestricted expected", yyStart);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unrestricted expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmodule(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("module expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("module expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.in.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pin(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("in expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("in expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.raises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result praises(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("raises expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("raises expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.getraises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pgetraises(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('s' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("getraises expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("getraises expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.WIDL.setraises.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psetraises(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('r' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('s' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('s' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyPredMatched = false;

                      yyPredResult = pidrest(yyIndex);
                      if (yyPredResult.hasValue()) {

                        yyPredMatched = true;
                      }

                      if (! yyPredMatched) {

                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("setraises expected", yyStart);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("setraises expected", yyStart);
    return yyError;
  }

  // =========================================================================

  static WEAttribute eaNoInterfaceObject = WIDLFactory.eaNoInterfaceObject();
  static WEAttribute eaCallbackFunctionOnly = WIDLFactory.eaCallbackFunctionOnly();
  static {
    add(JAVASCRIPT_RESERVED, new String[] {
      "DOMString",    "Date",         "Infinity",     "NaN",
      "any",          "attribute",    "boolean",      "byte",
      "callback",     "const",        "creator",      "deleter",
      "dictionary",   "double",       "enum",         "exception",
      "false",        "float",        "getter",       "implements",
      "inherit",      "interface",    "legacycaller", "long",
      "null",         "object",       "octet",        "optional",
      "or",           "partial",      "readonly",     "sequence",
      "setter",       "short",        "static",       "stringifier",
      "true",         "typedef",      "unrestricted", "unsigned",
      "void",
      
      // reserved identifiers
      /*
      "prototype",    "constructor",  "toString",
      */
      
      // for WebKitIDL
      "module",       "in",           "raises",        "getraises",
      "setraises"
    });
  }
  
  Span createSpan(int start, int end) {
    int i = end;
    while ( i >= 0 && yyData.length > i && yyData[i] == ' ' ) { i--; }
    if ( i-1 >= start )
    end = i-1;
    else
    end = start;
    Column s = column(start);
    Column e = column(end);
    SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column, start);
    SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column, end);
    return new Span(slStart, slEnd);
  }
  
  private SpanInfo makeSpanInfo(int start, int end) {
    return NodeFactory.makeOnlySpanInfo(createSpan(start, end));
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
