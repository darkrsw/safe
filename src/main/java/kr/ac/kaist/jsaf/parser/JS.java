// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.1,
// (C) 2004-2008 Robert Grimm,
// on Sunday, October 23, 2016 at 6:58:03 PM.
// Edit at your own risk.
// ===========================================================================

package kr.ac.kaist.jsaf.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import java.util.HashMap;
import kr.ac.kaist.jsaf.exceptions.SyntaxError;
import kr.ac.kaist.jsaf.nodes.*;
import kr.ac.kaist.jsaf.nodes_util.*;
import kr.ac.kaist.jsaf.useful.Useful;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.*;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.jsaf.exceptions.JSAFError.error;

/**
 * Packrat parser for grammar <code>kr.ac.kaist.jsaf.parser.JS</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.1, (C) 2004-2008 Robert Grimm.
 */
public final class JS extends ParserBase {

  /** The JAVASCRIPT_RESERVED set. */
  public static final Set<String> JAVASCRIPT_RESERVED = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result f$$Shared1;
    Result f$$Shared2;
    Result f$$Shared9;
    Result f$$Shared9$$Plus1;
    Result f$$Shared3;
    Result fJS$SourceElement;
    Result fJS$ModuleElement;
    Result f$$Shared15;
    Result fJS$FunctionDeclaration;
    Result fJS$Params;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fJS$Params$$Plus1;
    Result fJS$FunctionBody;
    Result fDeclaration$SourceElement;
    Result fDeclaration$ModuleElement;
    Result fDeclaration$FunctionDeclaration;
    Result fDeclaration$Params;
    Result fDeclaration$Params$$Plus1;
    Result fDeclaration$FunctionBody;
    Result fStatement;
    Result fStatement$$Star1;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fCaseClauses;
    Result fCaseClauses$$Star1;
    Result fExpression;
    Result fExpression$$Star1;
    Result fAssignment;
    Result fLeftHandSide;
    Result fMemberExpr;
    Result fMemberExpr$$Star1;
    Result fAssignmentNoIn;
    Result fLiteral$NumericLiteral;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fId;
    Result fIdName;
    Result fPath;
    Result fPath$$Star1;
    Result fand;
    Result fands;
    Result fbar;
    Result fbars;
    Result fcaret;
    Result fequals;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fdoubleplus;
    Result fdoubleminus;
    Result fplus;
    Result fminus;
    Result fAssignmentOp;
    Result fEqualityOp;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class JSColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public JS(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public JS(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new JSColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJS$File(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Program    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = p$$Shared9(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a1.
        String a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJS$TopLevelSourceElements(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<SourceElement> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for a2.
            List<SourceElement> a2 = cast(yyOpValue1);

            yyResult = p$$Shared2(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              if (a2 == null) a2 = Collections.<SourceElement>emptyList();
              HashMap<String, Span> map = new HashMap<String, Span>();
              if (a1 == null)
              yyValue = NodeFactory.makeProgram(span, a2, false);
              else
              yyValue = NodeFactory.makeProgram(span, a2, true);

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for a2.
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared1.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.initParser and Declaration.initParser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared1) 
      yyColumn.chunk1.f$$Shared1 = p$$Shared1$1(yyStart);
    return yyColumn.chunk1.f$$Shared1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.$$Shared1. */
  private Result p$$Shared1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      initParser();

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.closeParser and Declaration.closeParser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared2) 
      yyColumn.chunk1.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk1.f$$Shared2;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEndOfFile(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        try {
          // revert to the original value for NodeUtil.keepComments
          NodeUtil.setKeepComments(keepComments);
          writer.close();
          fw.close();
        } catch (IOException error) {
          error("Closing a log file for the parser failed!");
        }

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared9.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.UseStrictDirectives 
   * and Declaration.UseStrictDirectives.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared9(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared9) 
      yyColumn.chunk1.f$$Shared9 = p$$Shared9$1(yyStart);
    return yyColumn.chunk1.f$$Shared9;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.$$Shared9. */
  private Result p$$Shared9$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared9$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        Span span = createSpan(yyStart,yyCount);
        System.out.println(span+":");
        System.out.println("    Warning: you may not use multiple Use Strict Directives.");

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared9$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared9$$Plus1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared9$$Plus1) 
      yyColumn.chunk1.f$$Shared9$$Plus1 = p$$Shared9$$Plus1$1(yyStart);
    return yyColumn.chunk1.f$$Shared9$$Plus1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.$$Shared9$$Plus1. */
  private Result p$$Shared9$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = p$$Shared9$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared3.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.UseStrictDirective 
   * and Declaration.UseStrictDirective.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared3(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared3) 
      yyColumn.chunk1.f$$Shared3 = p$$Shared3$1(yyStart);
    return yyColumn.chunk1.f$$Shared3;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.$$Shared3. */
  private Result p$$Shared3$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyBase = yyIndex;
          yyC    = character(yyBase);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if (' ' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('r' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('i' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('c' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('t' == yyC) {
                              yyIndex = yyIndex + 1;
                              yyValue = "use strict";

                              yyC = character(yyIndex);
                              if ('\"' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyOption1  = yyIndex;

                                yyResult = pw(yyOption1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  final int yyChoice1 = yyResult.index;

                                  // Nested alternative 1.

                                  yyResult = psemicolon(yyChoice1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                  }

                                  // Nested alternative 2.

                                  yyResult = pcomma(yyChoice1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                  }
                                }

                                return new SemanticValue(yyValue, yyOption1, yyError);
                              }
                            } else {
                              yyError = yyError.select("\"use strict\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"use strict\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"use strict\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"use strict\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"use strict\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"use strict\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"use strict\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"use strict\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"use strict\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"use strict\" expected", yyBase);
          }
        }
        break;

      case '\'':
        {
          yyBase = yyIndex;
          yyC    = character(yyBase);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if (' ' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('s' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('r' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('i' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('c' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('t' == yyC) {
                              yyIndex = yyIndex + 1;
                              yyValue = "use strict";

                              yyC = character(yyIndex);
                              if ('\'' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyOption1  = yyIndex;

                                yyResult = pw(yyOption1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  final int yyChoice1 = yyResult.index;

                                  // Nested alternative 1.

                                  yyResult = psemicolon(yyChoice1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                  }

                                  // Nested alternative 2.

                                  yyResult = pcomma(yyChoice1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyOption1  = yyResult.index;
                                  }
                                }

                                return new SemanticValue(yyValue, yyOption1, yyError);
                              }
                            } else {
                              yyError = yyError.select("\"use strict\" expected", yyBase);
                            }
                          } else {
                            yyError = yyError.select("\"use strict\" expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("\"use strict\" expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("\"use strict\" expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("\"use strict\" expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("\"use strict\" expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("\"use strict\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"use strict\" expected", yyBase);
              }
            } else {
              yyError = yyError.select("\"use strict\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"use strict\" expected", yyBase);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.TopLevelSourceElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$TopLevelSourceElements(final int yyStart) 
    throws IOException {

    Result              yyResult;
    int                 yyRepetition1;
    Pair<SourceElement> yyRepValue1;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJS$SourceElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pJS$SourceElement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            SourceElement v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<SourceElement>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SourceElement> a2s = yyRepValue1.reverse();

        // Disable recording comments for now for the end of file
        NodeUtil.setKeepComments(false);
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.SourceElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$SourceElements(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<SourceElement> yyRepValue1;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJS$SourceElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pJS$SourceElement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            SourceElement v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<SourceElement>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SourceElement> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.SourceElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$SourceElement(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fJS$SourceElement) 
      yyColumn.chunk1.fJS$SourceElement = pJS$SourceElement$1(yyStart);
    return yyColumn.chunk1.fJS$SourceElement;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.SourceElement. */
  private Result pJS$SourceElement$1(final int yyStart) throws IOException {
    Result        yyResult;
    SourceElement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJS$ModuleDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pJS$FunctionDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.ModuleDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$ModuleDeclaration(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyOption1;
    List<SourceElement> yyOpValue1;
    ModDecl             yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmodule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pJS$ModuleElements(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<SourceElement> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<SourceElement> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Span span = createSpan(yyStart,yyCount);
                    if (a2 == null) a2 = Collections.<SourceElement>emptyList();
                    yyValue = NodeFactory.makeModDecl(span, a1, a2, false);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.ModuleElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$ModuleElements(final int yyStart) throws IOException {
    Result              yyResult;
    int                 yyRepetition1;
    Pair<SourceElement> yyRepValue1;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJS$ModuleElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pJS$ModuleElement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            SourceElement v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<SourceElement>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SourceElement> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.ModuleElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$ModuleElement(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fJS$ModuleElement) 
      yyColumn.chunk1.fJS$ModuleElement = pJS$ModuleElement$1(yyStart);
    return yyColumn.chunk1.fJS$ModuleElement;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.ModuleElement. */
  private Result pJS$ModuleElement$1(final int yyStart) throws IOException {
    Result        yyResult;
    SourceElement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJS$ExportDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pJS$SourceElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.ExportDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$ExportDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    ModExport  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pvar(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pVariableDeclarationList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<VarDecl> a1 = yyResult.semanticValue();

              yyResult = pEOS(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                yyValue = NodeFactory.makeModExpVarStmt(span, a1);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pJS$FunctionDeclaration(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FunDecl a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeModExpFunDecl(span, a1);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pget(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pJS$FunctionBody(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a2 = yyResult.semanticValue();

                          Span span = createSpan(yyStart,yyCount);
                          yyValue = NodeFactory.makeModExpGetter(span, a1, a2.getA(), a2.getB());

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 4.

        yyResult = pset(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pId(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Id a2 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcloseparen(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pJS$FunctionBody(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = NodeFactory.makeModExpSetter(span, a1, a2, a3.getA(), a3.getB());

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 5.

        yyResult = p$$Shared12(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<ModExpSpecifier> a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeModExpSpecifiers(span, a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared12.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ExportSpecifierSetList 
   * and Declaration.ExportSpecifierSetList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared12(final int yyStart) throws IOException {
    Result                      yyResult;
    int                         yyRepetition1;
    Pair<List<ModExpSpecifier>> yyRepValue1;
    List<ModExpSpecifier>       yyValue;
    ParseError                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<ModExpSpecifier> a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared10(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<ModExpSpecifier> v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<List<ModExpSpecifier>>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<List<ModExpSpecifier>> a2s = yyRepValue1.reverse();

        List<ModExpSpecifier> result = new ArrayList<ModExpSpecifier>();
        result.addAll(a1);
        for (List<ModExpSpecifier> l: a2s.list()) result.addAll(l);
        yyValue = result;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared10.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ExportSpecifierSet 
   * and Declaration.ExportSpecifierSet.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared10(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<ModExpSpecifier> yyRepValue1;
    List<ModExpSpecifier> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared4(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ModExpSpecifier a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared4(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    ModExpSpecifier v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = 
                      new Pair<ModExpSpecifier>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<ModExpSpecifier> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                final int yyChoice1 = yyResult.index;

                // Nested alternative 1.

                yyResult = pw(yyChoice1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pfrom(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPath(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        Path a3 = yyResult.semanticValue();

                        List<ModExpSpecifier> result = new ArrayList<ModExpSpecifier>();
                        for (ModExpSpecifier s: Useful.cons(a1, a2s.list()))
                        result.add(NodeUtil.addPath(s, a3));
                        yyValue = result;

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }

                // Nested alternative 2.

                yyValue = Useful.cons(a1, a2s.list());

                return new SemanticValue(yyValue, yyChoice1, yyError);
              }
            }
          } // End scope for a2s.
        }
      }
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pfrom(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pPath(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Path a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = Useful.list(NodeFactory.makeExportName(span, a1, a2));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = Useful.list(NodeFactory.makeExportName(span, a1));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 3.

    yyResult = pstar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pfrom(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pPath(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Path a1 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = Useful.list(NodeFactory.makeStarFromPath(span, a1));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = Useful.list(NodeFactory.makeStar(span));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared4.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ExportSpecifier 
   * and Declaration.ExportSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared4(final int yyStart) throws IOException {
    Result          yyResult;
    ModExpSpecifier yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pPath(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Path a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeExportAlias(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeExportName(span, a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared15.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ImportDeclaration 
   * and Declaration.ImportDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared15) 
      yyColumn.chunk1.f$$Shared15 = p$$Shared15$1(yyStart);
    return yyColumn.chunk1.f$$Shared15;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.$$Shared15. */
  private Result p$$Shared15$1(final int yyStart) throws IOException {
    Result     yyResult;
    ModImpDecl yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pimport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared14(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<ModImport> a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeModImpDecl(span, a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared14.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ImportClauseList 
   * and Declaration.ImportClauseList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyRepetition1;
    Pair<ModImport> yyRepValue1;
    List<ModImport> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ModImport a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = p$$Shared13(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                ModImport v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<ModImport>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<ModImport> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared13.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ImportClause and Declaration.ImportClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared13(final int yyStart) throws IOException {
    Result     yyResult;
    ModImport  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared11(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<ModImpSpecifier> a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pfrom(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pPath(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Path a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeModImpSpecifierSet(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pPath(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Path a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pas(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeModImpAlias(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared11.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ImportSpecifierSet 
   * and Declaration.ImportSpecifierSet.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11(final int yyStart) throws IOException {
    Result                yyResult;
    int                   yyRepetition1;
    Pair<ModImpSpecifier> yyRepValue1;
    List<ModImpSpecifier> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = p$$Shared5(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          ModImpSpecifier a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pcomma(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = p$$Shared5(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    ModImpSpecifier v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = 
                      new Pair<ModImpSpecifier>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<ModImpSpecifier> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2s.
        }
      }
    }

    // Alternative 2.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = Useful.list(NodeFactory.makeImportName(span, a1));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared5.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.ImportSpecifier 
   * and Declaration.ImportSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared5(final int yyStart) throws IOException {
    Result          yyResult;
    ModImpSpecifier yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pw(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeImportAlias(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }

      // Nested alternative 2.

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeImportName(span, a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.FunctionDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJS$FunctionDeclaration(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fJS$FunctionDeclaration) 
      yyColumn.chunk1.fJS$FunctionDeclaration = pJS$FunctionDeclaration$1(yyStart);
    return yyColumn.chunk1.fJS$FunctionDeclaration;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.FunctionDeclaration. */
  private Result pJS$FunctionDeclaration$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    List<Id>   yyOpValue1;
    FunDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popenparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pJS$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Id> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<Id> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pJS$FunctionBody(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                        Span span = createSpan(yyStart,yyCount);
                        if (a2 == null) a2 = Collections.<Id>emptyList();
                        yyValue = NodeFactory.makeFunDecl(span, a1, a2, a3.getA(), a3.getB());

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJS$Params(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fJS$Params) 
      yyColumn.chunk1.fJS$Params = pJS$Params$1(yyStart);
    return yyColumn.chunk1.fJS$Params;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.Params. */
  private Result pJS$Params$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJS$Params$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JS.Params$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJS$Params$$Plus1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fJS$Params$$Plus1) 
      yyColumn.chunk2.fJS$Params$$Plus1 = pJS$Params$$Plus1$1(yyStart);
    return yyColumn.chunk2.fJS$Params$$Plus1;
  }

  /** Actually parse JS.Params$$Plus1. */
  private Result pJS$Params$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pJS$Params$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Id>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.FunctionBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJS$FunctionBody(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fJS$FunctionBody) 
      yyColumn.chunk2.fJS$FunctionBody = pJS$FunctionBody$1(yyStart);
    return yyColumn.chunk2.fJS$FunctionBody;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.FunctionBody. */
  private Result pJS$FunctionBody$1(final int yyStart) throws IOException {
    Result                                                    yyResult;
    int                                                       yyOption1;
    String                                                    yyOpValue1;
    kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> yyValue;
    ParseError                                                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = p$$Shared9(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for a1.
          String a1 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pclosecurly(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null)
              yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(Collections.<SourceElement>emptyList(),
              Boolean.valueOf(false));
              else
              yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(Collections.<SourceElement>emptyList(),
              Boolean.valueOf(true));

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyResult = pJS$SourceElements(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<SourceElement> a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  if (a1 == null)
                  yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(a2, Boolean.valueOf(false));
                  else
                  yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(a2, Boolean.valueOf(true));

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        } // End scope for a1.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.JS.FunctionExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJS$FunctionExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popenparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pJS$Params(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Id> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a2.
              List<Id> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pJS$FunctionBody(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      Id f = (a1 == null) ? NodeFactory.makeId(span, "", "") : a1;
                      if (a2 == null) a2 = Collections.<Id>emptyList();
                      yyValue = NodeFactory.makeFunExpr(span, f, a2, a3.getA(), a3.getB());

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.File.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration$File(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Program    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = p$$Shared9(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a1.
        String a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDeclaration$TopLevelSourceElements(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            List<SourceElement> v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for a2.
            List<SourceElement> a2 = cast(yyOpValue1);

            yyResult = p$$Shared2(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount);
              if (a2 == null) a2 = Collections.<SourceElement>emptyList();
              HashMap<String, Span> map = new HashMap<String, Span>();
              if (a1 == null)
              yyValue = NodeFactory.makeProgram(span, a2, false);
              else
              yyValue = NodeFactory.makeProgram(span, a2, true);

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for a2.
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.TopLevelSourceElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$TopLevelSourceElements(final int yyStart) 
    throws IOException {

    Result              yyResult;
    int                 yyRepetition1;
    Pair<SourceElement> yyRepValue1;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$SourceElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pDeclaration$SourceElement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            SourceElement v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<SourceElement>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SourceElement> a2s = yyRepValue1.reverse();

        // Disable recording comments for now for the end of file
        NodeUtil.setKeepComments(false);
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.SourceElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$SourceElements(final int yyStart) 
    throws IOException {

    Result              yyResult;
    int                 yyRepetition1;
    Pair<SourceElement> yyRepValue1;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$SourceElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pDeclaration$SourceElement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            SourceElement v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<SourceElement>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SourceElement> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.SourceElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$SourceElement(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclaration$SourceElement) 
      yyColumn.chunk2.fDeclaration$SourceElement = pDeclaration$SourceElement$1(yyStart);
    return yyColumn.chunk2.fDeclaration$SourceElement;
  }

  /** Actually parse Declaration.SourceElement. */
  private Result pDeclaration$SourceElement$1(final int yyStart) 
    throws IOException {

    Result        yyResult;
    SourceElement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$ModuleDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDeclaration$FunctionDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.ModuleDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$ModuleDeclaration(final int yyStart) 
    throws IOException {

    Result              yyResult;
    int                 yyOption1;
    List<SourceElement> yyOpValue1;
    ModDecl             yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmodule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popencurly(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pDeclaration$ModuleElements(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<SourceElement> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<SourceElement> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pclosecurly(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Span span = createSpan(yyStart,yyCount);
                    if (a2 == null) a2 = Collections.<SourceElement>emptyList();
                    yyValue = NodeFactory.makeModDecl(span, a1, a2, false);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.ModuleElements.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$ModuleElements(final int yyStart) 
    throws IOException {

    Result              yyResult;
    int                 yyRepetition1;
    Pair<SourceElement> yyRepValue1;
    List<SourceElement> yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$ModuleElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      SourceElement a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pDeclaration$ModuleElement(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            SourceElement v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<SourceElement>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<SourceElement> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.ModuleElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$ModuleElement(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclaration$ModuleElement) 
      yyColumn.chunk2.fDeclaration$ModuleElement = pDeclaration$ModuleElement$1(yyStart);
    return yyColumn.chunk2.fDeclaration$ModuleElement;
  }

  /** Actually parse Declaration.ModuleElement. */
  private Result pDeclaration$ModuleElement$1(final int yyStart) 
    throws IOException {

    Result        yyResult;
    SourceElement yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$ExportDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDeclaration$SourceElement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.ExportDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$ExportDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    ModExport  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pexport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pvar(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pVariableDeclarationList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<VarDecl> a1 = yyResult.semanticValue();

              yyResult = pEOS(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount);
                yyValue = NodeFactory.makeModExpVarStmt(span, a1);

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pDeclaration$FunctionDeclaration(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          FunDecl a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeModExpFunDecl(span, a1);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 3.

        yyResult = pget(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pDeclaration$FunctionBody(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a2 = yyResult.semanticValue();

                          Span span = createSpan(yyStart,yyCount);
                          yyValue = NodeFactory.makeModExpGetter(span, a1, a2.getA(), a2.getB());

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 4.

        yyResult = pset(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pId(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Id a2 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcloseparen(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = 
                              pDeclaration$FunctionBody(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = NodeFactory.makeModExpSetter(span, a1, a2, a3.getA(), a3.getB());

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // Nested alternative 5.

        yyResult = p$$Shared12(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<ModExpSpecifier> a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeModExpSpecifiers(span, a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.FunctionDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration$FunctionDeclaration(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclaration$FunctionDeclaration) 
      yyColumn.chunk2.fDeclaration$FunctionDeclaration = pDeclaration$FunctionDeclaration$1(yyStart);
    return yyColumn.chunk2.fDeclaration$FunctionDeclaration;
  }

  /** Actually parse Declaration.FunctionDeclaration. */
  private Result pDeclaration$FunctionDeclaration$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    List<Id>   yyOpValue1;
    FunDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popenparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pDeclaration$Params(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Id> v$el$1 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$1;
                }
              }
              { // Start scope for a2.
                List<Id> a2 = yyOpValue1;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pcloseparen(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pw(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pDeclaration$FunctionBody(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                        Span span = createSpan(yyStart,yyCount);
                        if (a2 == null) a2 = Collections.<Id>emptyList();
                        yyValue = NodeFactory.makeFunDecl(span, a1, a2, a3.getA(), a3.getB());

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              } // End scope for a2.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.Params.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration$Params(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclaration$Params) 
      yyColumn.chunk2.fDeclaration$Params = pDeclaration$Params$1(yyStart);
    return yyColumn.chunk2.fDeclaration$Params;
  }

  /** Actually parse Declaration.Params. */
  private Result pDeclaration$Params$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDeclaration$Params$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Id> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = Useful.list(a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal Declaration.Params$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration$Params$$Plus1(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclaration$Params$$Plus1) 
      yyColumn.chunk2.fDeclaration$Params$$Plus1 = pDeclaration$Params$$Plus1$1(yyStart);
    return yyColumn.chunk2.fDeclaration$Params$$Plus1;
  }

  /** Actually parse Declaration.Params$$Plus1. */
  private Result pDeclaration$Params$$Plus1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pId(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Id v$el$1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pDeclaration$Params$$Plus1(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Id> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Id>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyValue = new Pair<Id>(v$el$1);

            return new SemanticValue(yyValue, yyChoice1, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.FunctionBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration$FunctionBody(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDeclaration$FunctionBody) 
      yyColumn.chunk2.fDeclaration$FunctionBody = pDeclaration$FunctionBody$1(yyStart);
    return yyColumn.chunk2.fDeclaration$FunctionBody;
  }

  /** Actually parse Declaration.FunctionBody. */
  private Result pDeclaration$FunctionBody$1(final int yyStart) 
    throws IOException {

    Result                                                    yyResult;
    int                                                       yyOption1;
    String                                                    yyOpValue1;
    kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> yyValue;
    ParseError                                                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = p$$Shared9(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for a1.
          String a1 = yyOpValue1;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pclosecurly(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              if (a1 == null)
              yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(Collections.<SourceElement>emptyList(),
              Boolean.valueOf(false));
              else
              yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(Collections.<SourceElement>emptyList(),
              Boolean.valueOf(true));

              return yyResult.createValue(yyValue, yyError);
            }

            // Nested alternative 2.

            yyResult = pDeclaration$SourceElements(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<SourceElement> a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pclosecurly(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  if (a1 == null)
                  yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(a2, Boolean.valueOf(false));
                  else
                  yyValue = new kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>, Boolean>(a2, Boolean.valueOf(true));

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            }
          }
        } // End scope for a1.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Declaration.FunctionExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDeclaration$FunctionExpr(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        Id a1 = cast(yyOpValue1);

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = popenparen(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pDeclaration$Params(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                List<Id> v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for a2.
              List<Id> a2 = cast(yyOpValue1);

              yyResult = pw(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pDeclaration$FunctionBody(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      Id f = (a1 == null) ? NodeFactory.makeId(span, "", "") : a1;
                      if (a2 == null) a2 = Collections.<Id>emptyList();
                      yyValue = NodeFactory.makeFunExpr(span, f, a2, a3.getA(), a3.getB());

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            } // End scope for a2.
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.NumericLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$NumericLiteral(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement$DecimalDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pidrest(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        log(a1);

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("numeric literal expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.DecimalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$DecimalDigits(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.NumericLiterals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNumericLiterals(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStatement$NumericLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        while (true) {

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = pw(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStatement$NumericLiteral(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pw(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  continue;
                }
              }
            }
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }
          break;
        }

        if (yyRepeated1) {

          yyValue = null;

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse Statement.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Object     yyOpValue1;
    Stmt       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Stmt> a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount+1);
      yyValue = NodeFactory.makeBlock(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pExtendedFunctionDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pvar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pId(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pequals(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pStatement$$Choice1(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Object a2 = yyResult.semanticValue();

                  yyResult = pEOS(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Span span = createSpan(yyStart,yyCount);
                    yyValue = makeArrayNumberLiteral(span, a1, (Span)a2);

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pVariableDeclarationList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<VarDecl> a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeVarStmt(span, a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 4.

    yyResult = psemicolon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeEmptyStmt(span);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pEOS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeExprStmt(span, a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 6.

    yyResult = pif(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pStatement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Stmt a2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pelse(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pStatement(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Stmt v$el$2 = yyResult.semanticValue();

                              yyOption1  = yyResult.index;
                              yyOpValue1 = v$el$2;
                            }
                          }
                        }
                      }
                      { // Start scope for a3.
                        Stmt a3 = cast(yyOpValue1);

                        Span span = createSpan(yyStart,yyCount);
                        Option<Stmt> elseB;
                        if (a3 == null) elseB = Option.<Stmt>none();
                        else            elseB = Option.<Stmt>some(a3);
                        yyValue = NodeFactory.makeIf(span, a1, a2, elseB);

                        return new SemanticValue(yyValue, yyOption1, yyError);
                      } // End scope for a3.
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 7.

    yyResult = pdo(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Stmt a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pwhile(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = popenparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a2 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcloseparen(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pEOS(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount);
                            yyValue = NodeFactory.makeDoWhile(span, a1, a2);

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 8.

    yyResult = pwhile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pStatement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Stmt a2 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = NodeFactory.makeWhile(span, a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 9.

    yyResult = pfor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;
          yyOpValue1 = null;

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpressionNoIn(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
          }
          { // Start scope for a1.
            Expr a1 = cast(yyOpValue1);

            yyResult = pw(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = psemicolon(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pw(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pExpression(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Expr v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                }
                { // Start scope for a2.
                  Expr a2 = cast(yyOpValue1);

                  yyResult = pw(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = psemicolon(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pExpression(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Expr v$el$5 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$5;
                        }
                      }
                      { // Start scope for a3.
                        Expr a3 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pcloseparen(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pStatement(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Stmt a4 = yyResult.semanticValue();

                                Span span = createSpan(yyStart,yyCount);
                                Option<Expr> init;
                                Option<Expr> test;
                                Option<Expr> update;
                                if (a1 == null) init = Option.<Expr>none();
                                else            init = Option.<Expr>some(a1);
                                if (a2 == null) test = Option.<Expr>none();
                                else            test = Option.<Expr>some(a2);
                                if (a3 == null) update = Option.<Expr>none();
                                else            update = Option.<Expr>some(a3);
                                yyValue = NodeFactory.makeFor(span, init, test, update, a4);

                                return yyResult.createValue(yyValue, yyError);
                              }
                            }
                          }
                        }
                      } // End scope for a3.
                    }
                  }
                } // End scope for a2.
              }
            }
          } // End scope for a1.

          // Nested alternative 2.

          yyResult = pw(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pvar(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pVariableDeclarationListNoIn(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<VarDecl> a1 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = psemicolon(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pExpression(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Expr v$el$6 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$6;
                        }
                      }
                      { // Start scope for a2.
                        Expr a2 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = psemicolon(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyOption1  = yyResult.index;
                            yyOpValue1 = null;

                            yyResult = pw(yyOption1);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pExpression(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {
                                Expr v$el$7 = yyResult.semanticValue();

                                yyOption1  = yyResult.index;
                                yyOpValue1 = v$el$7;
                              }
                            }
                            { // Start scope for a3.
                              Expr a3 = cast(yyOpValue1);

                              yyResult = pw(yyOption1);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pcloseparen(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyResult = pw(yyResult.index);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pStatement(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      Stmt a4 = yyResult.semanticValue();

                                      Span span = createSpan(yyStart,yyCount);
                                      Option<Expr> test;
                                      Option<Expr> update;
                                      if (a2 == null) test = Option.<Expr>none();
                                      else            test = Option.<Expr>some(a2);
                                      if (a3 == null) update = Option.<Expr>none();
                                      else            update = Option.<Expr>some(a3);
                                      yyValue = NodeFactory.makeForVar(span, a1, test, update, a4);

                                      return yyResult.createValue(yyValue, yyError);
                                    }
                                  }
                                }
                              }
                            } // End scope for a3.
                          }
                        }
                      } // End scope for a2.
                    }
                  }
                }
              }
            }

            // Nested alternative 2.

            yyResult = pLeftHandSide(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              LHS a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pin(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pExpression(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a2 = yyResult.semanticValue();

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pcloseparen(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pStatement(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {
                              Stmt a3 = yyResult.semanticValue();

                              Span span = createSpan(yyStart,yyCount);
                              yyValue = NodeFactory.makeForIn(span, a1, a2, a3);

                              return yyResult.createValue(yyValue, yyError);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            // Nested alternative 3.

            yyResult = pvar(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pVariableDeclarationNoIn(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  VarDecl a1 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pin(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pExpression(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          Expr a2 = yyResult.semanticValue();

                          yyResult = pw(yyResult.index);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pcloseparen(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pw(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pStatement(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Stmt a3 = yyResult.semanticValue();

                                  Span span = createSpan(yyStart,yyCount);
                                  yyValue = NodeFactory.makeForVarIn(span, a1, a2, a3);

                                  return yyResult.createValue(yyValue, yyError);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 10.

    yyResult = pcontinue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = ps(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeContinue(span, Option.<Label>some(NodeFactory.makeLabel(span, a1)));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pEOSnoLB(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeContinue(span, Option.<Label>none());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 11.

    yyResult = pbreak(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = ps(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pId(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Id a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeBreak(span, Option.<Label>some(NodeFactory.makeLabel(span, a1)));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pEOSnoLB(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeBreak(span, Option.<Label>none());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 12.

    yyResult = preturn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = ps(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeReturn(span, Option.<Expr>some(a1));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyResult = pEOSnoLB(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeReturn(span, Option.<Expr>none());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 13.

    yyResult = pwith(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pStatement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Stmt a2 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = NodeFactory.makeWith(span, a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 14.

    yyResult = pswitch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = popencurly(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyOption1  = yyResult.index;
                      yyOpValue1 = null;

                      yyResult = pw(yyOption1);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pCaseClauses(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          List<Case> v$el$8 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$8;
                        }
                      }
                      { // Start scope for a2.
                        List<Case> a2 = cast(yyOpValue1);

                        yyResult = pw(yyOption1);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {

                          final int yyChoice1 = yyResult.index;

                          // Nested alternative 1.

                          yyResult = pclosecurly(yyChoice1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            Span span = createSpan(yyStart,yyCount+1);
                            if (a2 == null) a2 = Useful.list();
                            yyValue = NodeFactory.makeSwitch(span, a1, a2);

                            return yyResult.createValue(yyValue, yyError);
                          }

                          // Nested alternative 2.

                          yyResult = pdefault(yyChoice1);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyResult = pw(yyResult.index);
                            yyError  = yyResult.select(yyError);
                            if (yyResult.hasValue()) {

                              yyResult = pcolon(yyResult.index);
                              yyError  = yyResult.select(yyError);
                              if (yyResult.hasValue()) {

                                yyResult = pStatement$$Star1(yyResult.index);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {
                                  Pair<Stmt> a3s = yyResult.semanticValue();

                                  yyOption1  = yyResult.index;
                                  yyOpValue1 = null;

                                  yyResult = pw(yyOption1);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {

                                    yyResult = pCaseClauses(yyResult.index);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {
                                      List<Case> v$el$11 = yyResult.semanticValue();

                                      yyOption1  = yyResult.index;
                                      yyOpValue1 = v$el$11;
                                    }
                                  }
                                  { // Start scope for a4.
                                    List<Case> a4 = cast(yyOpValue1);

                                    yyResult = pw(yyOption1);
                                    yyError  = yyResult.select(yyError);
                                    if (yyResult.hasValue()) {

                                      yyResult = pclosecurly(yyResult.index);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {

                                        Span span = createSpan(yyStart,yyCount+1);
                                        if (a2 == null) a2 = Useful.list();
                                        if (a4 == null) a4 = Useful.list();
                                        yyValue = NodeFactory.makeSwitch(span, a1, a2,
                                        Option.<List<Stmt>>some(a3s.list()), a4);

                                        return yyResult.createValue(yyValue, yyError);
                                      }
                                    }
                                  } // End scope for a4.
                                }
                              }
                            }
                          }
                        }
                      } // End scope for a2.
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 15.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Stmt a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeLabelStmt(span, NodeFactory.makeLabel(span, a1), a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 16.

    yyResult = pthrow(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pEOS(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeThrow(span, a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 17.

    yyResult = ptry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlock(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Stmt> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pCatch(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Catch a2 = yyResult.semanticValue();

              final int yyChoice2 = yyResult.index;

              // Nested alternative 1.

              yyResult = pw(yyChoice2);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pFinally(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  List<Stmt> a3 = yyResult.semanticValue();

                  Span span = createSpan(yyStart,yyCount);
                  yyValue = NodeFactory.makeTry(span, a1, a2, a3);

                  return yyResult.createValue(yyValue, yyError);
                }
              }

              // Nested alternative 2.

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeTry(span, a1, a2);

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

            // Nested alternative 2.

            yyResult = pFinally(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Stmt> a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeTry(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 18.

    yyResult = pdebugger(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEOS(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeDebugger(span);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.Statement$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Object     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNumericLiterals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosesquare(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = createSpan(yyStart,yyCount);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.Statement$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement$$Star1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement$$Star1) 
      yyColumn.chunk2.fStatement$$Star1 = pStatement$$Star1$1(yyStart);
    return yyColumn.chunk2.fStatement$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.Statement$$Star1. */
  private Result pStatement$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Stmt> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Stmt v$el$9 = yyResult.semanticValue();

        yyResult = pStatement$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Stmt> v$10 = yyResult.semanticValue();

          yyValue = new Pair<Stmt>(v$el$9, v$10);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.ExtendedFunctionDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtendedFunctionDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Stmt       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$FunctionDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      FunDecl a1 = yyResult.semanticValue();

      System.out.println(a1.getInfo().getSpan()+":");
      System.out.println("    Warning: the use of FunctionDeclaration as a Statement is not allowed in ECMAScript.");
      yyValue = a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Stmt> yyRepValue1;
    List<Stmt> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pclosecurly(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = Useful.<Stmt>list();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pStatement(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Stmt a1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pStatement(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Stmt v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Stmt>(v$el$1, yyRepValue1);
                continue;
              }
            }
            break;
          }
          { // Start scope for a2s.
            Pair<Stmt> a2s = yyRepValue1.reverse();

            yyResult = pw(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosecurly(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                Span span = createSpan(yyStart,yyCount+1);
                yyValue = Useful.cons(a1, a2s.list());

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } // End scope for a2s.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.VariableDeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableDeclarationList(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyRepetition1;
    Pair<VarDecl> yyRepValue1;
    List<VarDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariableDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDecl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pVariableDeclaration(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                VarDecl v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<VarDecl>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<VarDecl> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.VariableDeclarationListNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableDeclarationListNoIn(final int yyStart) 
    throws IOException {

    Result        yyResult;
    int           yyRepetition1;
    Pair<VarDecl> yyRepValue1;
    List<VarDecl> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariableDeclarationNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      VarDecl a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pVariableDeclarationNoIn(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                VarDecl v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<VarDecl>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<VarDecl> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.VariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Expr       yyOpValue1;
    VarDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Expr a2 = yyOpValue1;

        Span span = createSpan(yyStart,yyCount);
        Option<Expr> expr;
        if (a2 == null) expr = Option.<Expr>none();
        else            expr = Option.<Expr>some(a2);
        yyValue = NodeFactory.makeVarDecl(span, a1, expr);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.VariableDeclarationNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableDeclarationNoIn(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Expr       yyOpValue1;
    VarDecl    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pequals(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignmentNoIn(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
        }
      }
      { // Start scope for a2.
        Expr a2 = yyOpValue1;

        Span span = createSpan(yyStart,yyCount);
        Option<Expr> expr;
        if (a2 == null) expr = Option.<Expr>none();
        else            expr = Option.<Expr>some(a2);
        yyValue = NodeFactory.makeVarDecl(span, a1, expr);

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for a2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.CaseClauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCaseClauses) 
      yyColumn.chunk3.fCaseClauses = pCaseClauses$1(yyStart);
    return yyColumn.chunk3.fCaseClauses;
  }

  /** Actually parse Statement.CaseClauses. */
  private Result pCaseClauses$1(final int yyStart) throws IOException {
    Result     yyResult;
    List<Case> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCaseClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Case a1 = yyResult.semanticValue();

      yyResult = pCaseClauses$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Case> a2s = yyResult.semanticValue();

        yyValue = Useful.cons(a1, a2s.list());

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.CaseClauses$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClauses$$Star1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCaseClauses$$Star1) 
      yyColumn.chunk3.fCaseClauses$$Star1 = pCaseClauses$$Star1$1(yyStart);
    return yyColumn.chunk3.fCaseClauses$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.CaseClauses$$Star1. */
  private Result pCaseClauses$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Case> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCaseClause(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Case v$el$1 = yyResult.semanticValue();

        yyResult = pCaseClauses$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Case> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Case>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.CaseClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCaseClause(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Stmt> yyRepValue1;
    Case       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcase(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcolon(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyResult = pw(yyRepetition1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pStatement(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Stmt v$el$1 = yyResult.semanticValue();

                    yyRepetition1 = yyResult.index;
                    yyRepValue1   = new Pair<Stmt>(v$el$1, yyRepValue1);
                    continue;
                  }
                }
                break;
              }
              { // Start scope for a2s.
                Pair<Stmt> a2s = yyRepValue1.reverse();

                Span span = createSpan(yyStart,yyCount);
                yyValue = NodeFactory.makeCase(span, a1, a2s.list());

                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for a2s.
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.Catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatch(final int yyStart) throws IOException {
    Result     yyResult;
    Catch      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = popenparen(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pId(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Id a1 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pBlock(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      List<Stmt> a2 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = NodeFactory.makeCatch(span, a1, a2);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Statement.Finally.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFinally(final int yyStart) throws IOException {
    Result     yyResult;
    List<Stmt> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfinally(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pBlock(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpression) 
      yyColumn.chunk3.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk3.fExpression;
  }

  /** Actually parse Expression.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pExpression$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Expr> a2s = yyResult.semanticValue();

        if (a2s.list().isEmpty()) yyValue = a1;
        else yyValue = NodeFactory.makeExprList(createSpan(yyStart,yyCount),
        Useful.cons(a1, a2s.list()));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.Expression$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression$$Star1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpression$$Star1) 
      yyColumn.chunk3.fExpression$$Star1 = pExpression$$Star1$1(yyStart);
    return yyColumn.chunk3.fExpression$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.Expression$$Star1. */
  private Result pExpression$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pAssignment(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr v$el$1 = yyResult.semanticValue();

            yyResult = pExpression$$Star1(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Pair<Expr> v$2 = yyResult.semanticValue();

              yyValue = new Pair<Expr>(v$el$1, v$2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Assignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignment(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssignment) 
      yyColumn.chunk3.fAssignment = pAssignment$1(yyStart);
    return yyColumn.chunk3.fAssignment;
  }

  /** Actually parse Expression.Assignment. */
  private Result pAssignment$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeAssignOpApp(span, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pAssignmentOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeAssignOpApp(span, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pConditional(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Conditional.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConditional(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pquestion(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcolon(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pAssignment(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a3 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = NodeFactory.makeCond(span, a1, a2, a3);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pLogicalOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LogicalOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOR(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalAND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalANDR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LogicalANDR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalANDR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbars(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLogicalAND(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LogicalAND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAND(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseORR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseORR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseORR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pands(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseOR(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseOR(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseXOR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseXORR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseXORR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXORR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbar(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseXOR(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseXOR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXOR(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseAND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseANDR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseANDR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseANDR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcaret(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseAND(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.BitwiseAND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseAND(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEquality(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.EqualityR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pand(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEquality(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Equality.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEquality(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelational(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRelationalR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.RelationalR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEqualityOp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pRelational(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Relational.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelational(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    boolean                                     yyRepeated1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pShiftL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        kr.ac.kaist.jsaf.useful.Pair<Expr,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = 
          new Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> a1s = yyRepValue1.reverse();

      yyResult = pShift(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
        kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
        Expr left = first.getA();
        Op op = first.getB();
        Span span = NodeUtil.getSpan(left);
        for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
          Expr e = pair.getA();
          left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
          left, op, e);
          op = pair.getB();
        }
        yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pShift(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ShiftL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftL(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Expr,Op> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pShift(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pRelationalOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Shift.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShift(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    boolean                                     yyRepeated1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pAdditiveL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        kr.ac.kaist.jsaf.useful.Pair<Expr,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = 
          new Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> a1s = yyRepValue1.reverse();

      yyResult = pAdditive(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
        kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
        Expr left = first.getA();
        Op op = first.getB();
        Span span = NodeUtil.getSpan(left);
        for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
          Expr e = pair.getA();
          left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
          left, op, e);
          op = pair.getB();
        }
        yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pAdditive(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.AdditiveL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveL(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Expr,Op> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAdditive(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pShiftOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Additive.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditive(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    boolean                                     yyRepeated1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pMultiplicativeL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        kr.ac.kaist.jsaf.useful.Pair<Expr,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = 
          new Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> a1s = yyRepValue1.reverse();

      yyResult = pMultiplicative(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
        kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
        Expr left = first.getA();
        Op op = first.getB();
        Span span = NodeUtil.getSpan(left);
        for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
          Expr e = pair.getA();
          left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
          left, op, e);
          op = pair.getB();
        }
        yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pMultiplicative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MultiplicativeL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeL(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Expr,Op> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMultiplicative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pAdditiveOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Multiplicative.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicative(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    boolean                                     yyRepeated1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pUnaryL(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        kr.ac.kaist.jsaf.useful.Pair<Expr,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = 
          new Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> a1s = yyRepValue1.reverse();

      yyResult = pUnary(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
        kr.ac.kaist.jsaf.useful.Pair<Expr, Op> first = ps.remove(0);
        Expr left = first.getA();
        Op op = first.getB();
        Span span = NodeUtil.getSpan(left);
        for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps) {
          Expr e = pair.getA();
          left = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(e)),
          left, op, e);
          op = pair.getB();
        }
        yyValue = NodeFactory.makeInfixOpApp(createSpan(yyStart,yyCount), left, op, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.UnaryL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryL(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Expr,Op> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMultiplicativeOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Unary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnary(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pdelete(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pvoid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = ptypeof(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyResult = pdoubleplus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pdoubleminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 6.

    yyResult = pplus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 8.

    yyResult = ptilde(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pbang(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Op a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pUnary(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makePrefixOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 10.

    yyResult = pPostfix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Postfix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfix(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS a1 = yyResult.semanticValue();

      yyResult = ps(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pdoubleplus(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeUnaryAssignOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pdoubleminus(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeUnaryAssignOpApp(span, a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.LeftHandSide.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftHandSide(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLeftHandSide) 
      yyColumn.chunk3.fLeftHandSide = pLeftHandSide$1(yyStart);
    return yyColumn.chunk3.fLeftHandSide;
  }

  /** Actually parse Expression.LeftHandSide. */
  private Result pLeftHandSide$1(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCallExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pNewExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CallExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExpr(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<Action<LHS>> yyRepValue1;
    LHS               yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCallExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCallExprTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<LHS> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<LHS>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<LHS>> list = yyRepValue1.reverse();

        yyValue = (LHS)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CallExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pArgs(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Expr> a2 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount+1);
          yyValue = NodeFactory.makeFunApp(NodeUtil.adjustCallSpan(span, a1), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.CallExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCallExprTail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<LHS> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pArgs(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final List<Expr> a1 = yyResult.semanticValue();

        yyValue = new Action<LHS>() {
          public LHS run(LHS base) {
            Span span;
            if (a1.isEmpty()) span = NodeUtil.getSpan(base);
            else span = NodeUtil.spanAll(NodeUtil.getSpan(base),
            createSpan(yyStart,yyCount+1));
            return NodeFactory.makeFunApp(NodeUtil.adjustCallSpan(span, (LHS)base),
            (LHS)base, a1);
        }};

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = popensquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expr a1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<LHS>() {
                  public LHS run(LHS base) {
                    SourceLoc loc = NodeUtil.getSpan(base).getBegin();
                    Span span = NodeFactory.makeSpan(loc.getFileName(), loc.getLine(),
                    loc.column()+1, NodeUtil.getSpan(a1).getEnd().column()+1);
                    return NodeFactory.makeBracket(span,
                    (LHS)base, a1);
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }

      // Nested alternative 3.

      yyResult = pdot(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Id a1 = yyResult.semanticValue();

            yyValue = new Action<LHS>() {
              public LHS run(LHS base) {
                return NodeFactory.makeDot(NodeFactory.makeSpan(NodeUtil.getSpan(base),
                NodeUtil.getSpan(a1)),
                (LHS)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Args.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgs(final int yyStart) throws IOException {
    Result     yyResult;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pcloseparen(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = Useful.list();

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pArgList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Expr> yyRepValue1;
    List<Expr> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAssignment(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expr> a2s = yyRepValue1.reverse();

        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.NewExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewExpr(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pnew(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pNewExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LHS a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeNew(span, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MemberExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExpr(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMemberExpr) 
      yyColumn.chunk3.fMemberExpr = pMemberExpr$1(yyStart);
    return yyColumn.chunk3.fMemberExpr;
  }

  /** Actually parse Expression.MemberExpr. */
  private Result pMemberExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExprFront(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS seed = yyResult.semanticValue();

      yyResult = pMemberExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<LHS>> list = yyResult.semanticValue();

        yyValue = (LHS)apply(list, seed);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.MemberExpr$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExpr$$Star1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMemberExpr$$Star1) 
      yyColumn.chunk3.fMemberExpr$$Star1 = pMemberExpr$$Star1$1(yyStart);
    return yyColumn.chunk3.fMemberExpr$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.MemberExpr$$Star1. */
  private Result pMemberExpr$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Pair<Action<LHS>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMemberExprTail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<LHS> v$el$1 = yyResult.semanticValue();

      yyResult = pMemberExpr$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<Action<LHS>> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Action<LHS>>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MemberExprFront.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExprFront(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclaration$FunctionExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPrimaryExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pnew(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pMemberExpr(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          LHS a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pArgs(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              List<Expr> a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount+1);
              yyValue = NodeFactory.makeNew(span, NodeFactory.makeFunApp(span, a1, a2));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.MemberExprTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMemberExprTail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<LHS> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = popensquare(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Expr a1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pclosesquare(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = new Action<LHS>() {
                  public LHS run(LHS base) {
                    SourceLoc loc = NodeUtil.getSpan(base).getBegin();
                    Span span = NodeFactory.makeSpan(loc.getFileName(), loc.getLine(),
                    loc.column()+1, NodeUtil.getSpan(a1).getEnd().column()+1);
                    return NodeFactory.makeBracket(span,
                    (LHS)base, a1);
                }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyResult = pdot(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdName(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Id a1 = yyResult.semanticValue();

            yyValue = new Action<LHS>() {
              public LHS run(LHS base) {
                return NodeFactory.makeDot(NodeFactory.makeSpan(NodeUtil.getSpan(base),
                NodeUtil.getSpan(a1)),
                (LHS)base, a1);
            }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.PrimaryExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryExpr(final int yyStart) throws IOException {
    Result     yyResult;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pthis(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeThis(span);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeVarRef(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pArrayLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pObjectLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = popenparen(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Expr a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pcloseparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount+1);
              yyValue = NodeFactory.makeParenthesized(span, a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ArrayLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Integer    yyOpValue1;
    LHS        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popensquare(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pElementList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Option<Expr>> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            final int yyChoice2 = yyResult.index;

            // Nested alternative 1.

            yyResult = pcomma(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pElision(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Integer v$el$1 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$1;
                  }
                }
                { // Start scope for a2.
                  Integer a2 = yyOpValue1;

                  yyResult = pclosesquare(yyOption1);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    Span span = createSpan(yyStart,yyCount+1);
                    int elision;
                    if (a2 == null) elision = 0; else elision = a2.intValue();
                    List<Option<Expr>> result = new ArrayList<Option<Expr>>();
                    result.addAll(a1);
                    for (int i = 0; i < elision; i++)
                    result.add(Option.<Expr>none());
                    writer.close(); initParser();
                    yyValue = NodeFactory.makeArrayExpr(span, result);

                    return yyResult.createValue(yyValue, yyError);
                  }
                } // End scope for a2.
              }
            }

            // Nested alternative 2.

            yyResult = pclosesquare(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              Span span = createSpan(yyStart,yyCount+1);
              writer.close(); initParser();
              yyValue = NodeFactory.makeArrayExpr(span, a1);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pElision(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Integer v$el$2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        }
        { // Start scope for a1.
          Integer a1 = yyOpValue1;

          yyResult = pclosesquare(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount+1);
            int elision;
            if (a1 == null) elision = 0; else elision = a1.intValue();
            List<Option<Expr>> result = new ArrayList<Option<Expr>>(elision);
            for (int i = 0; i < elision; i++)
            result.add(Option.<Expr>none());
            writer.close(); initParser();
            yyValue = NodeFactory.makeArrayExpr(span, result);

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for a1.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ElementList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementList(final int yyStart) throws IOException {
    Result                           yyResult;
    int                              yyRepetition1;
    Pair<Action<List<Option<Expr>>>> yyRepValue1;
    List<Option<Expr>>               yyValue;
    ParseError                       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElementListHead(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      List<Option<Expr>> seed = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pElementListTail(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Action<List<Option<Expr>>> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<Action<List<Option<Expr>>>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for list.
        Pair<Action<List<Option<Expr>>>> list = yyRepValue1.reverse();

        yyValue = (List<Option<Expr>>)apply(list, seed);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for list.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ElementListHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementListHead(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyOption1;
    Integer            yyOpValue1;
    List<Option<Expr>> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pElision(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Integer v$el$1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for a1.
      Integer a1 = yyOpValue1;

      yyResult = pAssignment(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        int elision;
        if (a1 == null) elision = 0; else elision = a1.intValue();
        List<Option<Expr>> result = new ArrayList<Option<Expr>>(elision);
        for (int i = 0; i < elision; i++)
        result.add(Option.<Expr>none());
        yyValue = Useful.list(result, Option.some(a2));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ElementListTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementListTail(final int yyStart) throws IOException {
    Result                     yyResult;
    int                        yyOption1;
    Integer                    yyOpValue1;
    Action<List<Option<Expr>>> yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcomma(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pElision(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Integer v$el$1 = yyResult.semanticValue();

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          }
          { // Start scope for a1.
            final Integer a1 = yyOpValue1;

            yyResult = pAssignment(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Expr a2 = yyResult.semanticValue();

              yyValue = new Action<List<Option<Expr>>>() {
                public List<Option<Expr>> run(List<Option<Expr>> base) {
                  int elision;
                  if (a1 == null) elision = 0; else elision = a1.intValue();
                  List<Option<Expr>> result = new ArrayList<Option<Expr>>();
                  result.addAll(base);
                  for (int i = 0; i < elision; i++)
                  result.add(Option.<Expr>none());
                  return Useful.list(result, Option.some(a2));
              }};

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for a1.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.Elision.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElision(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    boolean      yyRepeated1;
    Pair<String> yyRepValue1;
    Integer      yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pw(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcomma(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepeated1   = true;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
      }
      break;
    }

    if (yyRepeated1) {
      Pair<String> a1s = yyRepValue1.reverse();

      yyValue = a1s.size();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.ObjectLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObjectLiteral(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyOption1;
    List<Member> yyOpValue1;
    LHS          yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = popencurly(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPropAssignList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<Member> v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      }
      { // Start scope for a1.
        List<Member> a1 = yyOpValue1;


        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }
        }

        yyResult = pw(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pclosecurly(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            Span span = createSpan(yyStart,yyCount+1);
            if (a1 == null) a1 = Useful.list();
            yyValue = NodeFactory.makeObjectExpr(span, a1);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.PropAssignList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPropAssignList(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<Member> yyRepValue1;
    List<Member> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPropAssign(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Member a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pPropAssign(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Member v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Member>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Member> a2s = yyRepValue1.reverse();

        Span span = createSpan(yyStart,yyCount);
        yyValue = Useful.cons(a1, a2s.list());

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.PropAssign.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPropAssign(final int yyStart) throws IOException {
    Result     yyResult;
    Member     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Getter>.

    yyResult = pget(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPropName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Property a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popenparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcloseparen(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pDeclaration$FunctionBody(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a2 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = NodeFactory.makeGetProp(span, a1, a2.getA(), a2.getB());

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative <Setter>.

    yyResult = pset(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPropName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Property a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = popenparen(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pId(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Id a2 = yyResult.semanticValue();

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pcloseparen(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pw(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyResult = pDeclaration$FunctionBody(yyResult.index);
                        yyError  = yyResult.select(yyError);
                        if (yyResult.hasValue()) {
                          kr.ac.kaist.jsaf.useful.Pair<List<SourceElement>,Boolean> a3 = yyResult.semanticValue();

                          Span span = createSpan(yyStart,yyCount);
                          yyValue = NodeFactory.makeSetProp(span, a1, a2, a3.getA(), a3.getB());

                          return yyResult.createValue(yyValue, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative <Prop>.

    yyResult = pPropName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Property a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pcolon(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeField(span, a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Expression.PropName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPropName(final int yyStart) throws IOException {
    Result     yyResult;
    Property   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makePropId(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      StringLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makePropStr(span, a1.getEscaped());

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pLiteral$NumericLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NumberLiteral a1 = yyResult.semanticValue();

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makePropNum(span, a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.ExpressionNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionNoIn(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Expr> yyRepValue1;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pcomma(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pw(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pAssignmentNoIn(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Expr v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Expr>(v$el$1, yyRepValue1);
                continue;
              }
            }
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<Expr> a2s = yyRepValue1.reverse();

        if (a2s.list().isEmpty()) yyValue = a1;
        else yyValue = NodeFactory.makeExprList(createSpan(yyStart,yyCount),
        Useful.cons(a1, a2s.list()));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.AssignmentNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentNoIn(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssignmentNoIn) 
      yyColumn.chunk3.fAssignmentNoIn = pAssignmentNoIn$1(yyStart);
    return yyColumn.chunk3.fAssignmentNoIn;
  }

  /** Actually parse ExpressionNoIn.AssignmentNoIn. */
  private Result pAssignmentNoIn$1(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftHandSide(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LHS a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pequals(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignmentNoIn(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeAssignOpApp(span, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }

        // Nested alternative 2.

        yyResult = pAssignmentOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignmentNoIn(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a3 = yyResult.semanticValue();

              Span span = createSpan(yyStart,yyCount);
              yyValue = NodeFactory.makeAssignOpApp(span, a1, a2, a3);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pConditionalNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.ConditionalNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConditionalNoIn(final int yyStart) throws IOException {
    Result     yyResult;
    Expr       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalORNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pquestion(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pAssignment(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Expr a2 = yyResult.semanticValue();

              yyResult = pw(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pcolon(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pw(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pAssignmentNoIn(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Expr a3 = yyResult.semanticValue();

                      Span span = createSpan(yyStart,yyCount);
                      yyValue = NodeFactory.makeCond(span, a1, a2, a3);

                      return yyResult.createValue(yyValue, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pLogicalORNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.LogicalORNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalORNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLogicalANDNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalANDNoInR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.LogicalANDNoInR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalANDNoInR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbars(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pLogicalANDNoIn(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.LogicalANDNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalANDNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseORNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseORNoInR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.BitwiseORNoInR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseORNoInR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pands(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseORNoIn(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.BitwiseORNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseORNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseXORNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseXORNoInR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.BitwiseXORNoInR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXORNoInR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbar(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseXORNoIn(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.BitwiseXORNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXORNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBitwiseANDNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseANDNoInR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.BitwiseANDNoInR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseANDNoInR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pcaret(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pBitwiseANDNoIn(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.BitwiseANDNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseANDNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEqualityNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityNoInR(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          kr.ac.kaist.jsaf.useful.Pair<Op,Expr> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = 
            new Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<Op,Expr>> a2s = yyRepValue1.reverse();

        Span span = NodeUtil.getSpan(a1);
        yyValue = a1;
        for (kr.ac.kaist.jsaf.useful.Pair<Op, Expr> pair: a2s.list()) {
          Op op = pair.getA();
          Expr right = pair.getB();
          yyValue = NodeFactory.makeInfixOpApp(NodeFactory.makeSpan(span, NodeUtil.getSpan(right)),
          yyValue, op, right);
        }

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.EqualityNoInR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityNoInR(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Op,Expr> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pand(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Op a1 = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEqualityNoIn(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Expr a2 = yyResult.semanticValue();

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Op, Expr>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.EqualityNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    boolean                                     yyRepeated1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pRelationalLNoIn(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        kr.ac.kaist.jsaf.useful.Pair<Expr,Op> v$el$2 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = 
          new Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>>(v$el$2, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> a1s = yyRepValue1.reverse();

      yyResult = pRelationalNoIn(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        Span span = createSpan(yyStart,yyCount);
        yyValue = a2;
        List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
        Collections.reverse(ps);
        for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps)
        yyValue = NodeFactory.makeInfixOpApp(span, pair.getA(), pair.getB(), yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pRelationalNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.RelationalLNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalLNoIn(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Expr,Op> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelationalNoIn(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pEqualityOp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.RelationalNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalNoIn(final int yyStart) throws IOException {
    Result                                      yyResult;
    int                                         yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> yyRepValue1;
    Expr                                        yyValue;
    ParseError                                  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pShiftLNoIn(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        kr.ac.kaist.jsaf.useful.Pair<Expr,Op> v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = 
          new Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for a1s.
      Pair<kr.ac.kaist.jsaf.useful.Pair<Expr,Op>> a1s = yyRepValue1.reverse();

      yyResult = pShift(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Expr a2 = yyResult.semanticValue();

        Span span = createSpan(yyStart,yyCount);
        yyValue = a2;
        List<kr.ac.kaist.jsaf.useful.Pair<Expr, Op>> ps = a1s.list();
        Collections.reverse(ps);
        for (kr.ac.kaist.jsaf.useful.Pair<Expr, Op> pair: ps)
        yyValue = NodeFactory.makeInfixOpApp(span, pair.getA(), pair.getB(), yyValue);

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for a1s.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal ExpressionNoIn.ShiftLNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftLNoIn(final int yyStart) throws IOException {
    Result                                yyResult;
    kr.ac.kaist.jsaf.useful.Pair<Expr,Op> yyValue;
    ParseError                            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pShift(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Expr a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pRelationalOpNoIn(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Op a2 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new kr.ac.kaist.jsaf.useful.Pair<Expr, Op>(a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Literal    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pnullL(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeNull(span);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = ptrue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeBool(span, true);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pfalse(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      Span span = createSpan(yyStart,yyCount);
      yyValue = NodeFactory.makeBool(span, false);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pLiteral$NumericLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pRegularExpressionLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NumericLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral$NumericLiteral(final int yyStart) 
    throws IOException {

    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLiteral$NumericLiteral) 
      yyColumn.chunk3.fLiteral$NumericLiteral = pLiteral$NumericLiteral$1(yyStart);
    return yyColumn.chunk3.fLiteral$NumericLiteral;
  }

  /** Actually parse Literal.NumericLiteral. */
  private Result pLiteral$NumericLiteral$1(final int yyStart) 
    throws IOException {

    Result        yyResult;
    Result        yyPredResult;
    boolean       yyPredMatched;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pidrest(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("numeric literal expected", yyStart);
      }
    }

    // Alternative 2.

    yyResult = pOctalIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pidrest(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("numeric literal expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pDecimalLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyPredResult = pidrest(yyResult.index);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("numeric literal expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DecimalLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalLiteral(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyOption1;
    String        yyOpValue1;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLiteral$DecimalDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pdot(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        String a2 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pLiteral$DecimalDigits(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for a3.
          String a3 = yyOpValue1;

          yyOpValue1 = null;

          yyResult = pExponentPart(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for a4.
            String a4 = yyOpValue1;

            if (Character.isDigit(a1.charAt(0)) || a1.charAt(0) == '.') {

              Span span = createSpan(yyStart,yyCount);
              if (a2 == null) a2 = "";
              if (a3 == null) a3 = "";
              if (a4 == null) a4 = "";
              yyValue = NodeFactory.makeNumericLiteral(writer, span, a1, a2, a3, a4);

              return new SemanticValue(yyValue, yyOption1, yyError);
            }
          } // End scope for a4.
        } // End scope for a3.
      } // End scope for a2.
    }

    // Alternative 2.

    yyResult = pdot(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pLiteral$DecimalDigits(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$4 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$4;
      }
      { // Start scope for a1.
        String a1 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pExponentPart(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$5 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$5;
        }
        { // Start scope for a2.
          String a2 = yyOpValue1;

          if ((a1 != null) && (Character.isDigit(a1.charAt(0)) || a1.charAt(0) == '.')) {

            Span span = createSpan(yyStart,yyCount);
            if (a1 == null) a1 = "";
            if (a2 == null) a2 = "";
            yyValue = NodeFactory.makeNumericLiteral(writer, span, "", ".", a1, a2);

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        } // End scope for a2.
      } // End scope for a1.
    }

    // Done.
    yyError = yyError.select("decimal literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DecimalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral$DecimalDigits(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.ExponentPart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentPart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Character  yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;
          yyOpValue1 = null;

          yyResult = pExponentPart$$Choice1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Character v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for a1.
            Character a1 = yyOpValue1;

            yyResult = pLiteral$DecimalDigits(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a2 = yyResult.semanticValue();

              if (a1 == null) yyValue = "e"+a2;
              else          yyValue = "e"+a1+a2;

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for a1.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.ExponentPart$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentPart$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("exponent part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexIntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexIntegerLiteral(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pHexIntegerLiteral$$Choice1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pHexDigits(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a1 = yyResult.semanticValue();

          Span span = createSpan(yyStart,yyCount);
          yyValue = NodeFactory.makeHexIntegerLiteral(span, a1);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("hex integer literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.HexIntegerLiteral$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexIntegerLiteral$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'x':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'X':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex integer literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral$HexDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.HexDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("hex digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.OctalIntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalIntegerLiteral(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    NumberLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pOctalDigits(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        Span span = createSpan(yyStart,yyCount);
        yyValue = NodeFactory.makeOctalIntegerLiteral(span, a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("octal integer literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.OctalDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("octal digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.OctalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("octal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    int           yyC;
    int           yyIndex;
    Result        yyResult;
    int           yyRepetition1;
    Pair<String>  yyRepValue1;
    StringLiteral yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
        {
          yyRepetition1 = yyIndex;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pDoubleStringCharacter(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a1s.
            Pair<String> a1s = yyRepValue1.reverse();

            yyC = character(yyRepetition1);
            if ('\"' == yyC) {
              yyIndex = yyRepetition1 + 1;

              String str = "";
              for (String c : (List<String>)a1s.list()) str = str.concat(c);
              yyValue = NodeFactory.makeStringLiteral(createSpan(yyStart,yyCount+1), str, "\"");

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          } // End scope for a1s.
        }
        break;

      case '\'':
        {
          yyRepetition1 = yyIndex;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pSingleStringCharacter(yyRepetition1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$2 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$2, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for a1s.
            Pair<String> a1s = yyRepValue1.reverse();

            yyC = character(yyRepetition1);
            if ('\'' == yyC) {
              yyIndex = yyRepetition1 + 1;

              String str = "";
              for (String c : (List<String>)a1s.list()) str = str.concat(c);
              yyValue = NodeFactory.makeStringLiteral(createSpan(yyStart,yyCount+1), str, "\'");

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          } // End scope for a1s.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.DoubleStringCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleStringCharacter(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pEscapeSequence(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pLineContinuation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pDoubleStringCharacter$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = String.valueOf(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("double string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.DoubleStringCharacter$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDoubleStringCharacter$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonDoubleStringChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("double string character expected", yyStart);
    }

    // Done.
    yyError = yyError.select("double string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' == a1) ||
          ('\'' == a1) ||
          ('\\' == a1) ||
          ('b' == a1) ||
          ('f' == a1) ||
          ('n' == a1) ||
          ('r' == a1) ||
          ('t' == a1) ||
          ('v' == a1)) {

        switch (a1) {
          case 'b': { yyValue = "\\b"; break; }
          case 't': { yyValue = "\\t"; break; }
          case 'n': { yyValue = "\\n"; break; }
          case 'f': { yyValue = "\\f"; break; }
          case 'r': { yyValue = "\\r"; break; }
          case 'v': { yyValue = "\\v"; break; }
          case '"': { yyValue = "\\\""; break; }
          case '\'': { yyValue = "\\'"; break; }
          case '\\': { yyValue = "\\\\"; break; }
          default : { yyValue = ""; break; }
        }

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = pEscapeSequence$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = "\\"+a1+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        if (('0' <= yyC) && (yyC <= '9')) {

          yyPredMatched = true;
        }
      }

      if (! yyPredMatched) {

        yyValue = "\\0";

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("escape sequence expected", yyStart);
      }
    }

    // Alternative 4.

    yyResult = pOctalDigit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pOctalDigit(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = "\\"+a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = "\\"+a1;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('0' <= a1) && (a1 <= '3')) {

        yyResult = pOctalDigit(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyResult = pOctalDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a3 = yyResult.semanticValue();

            yyValue = "\\"+a1+a2+a3;

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('x' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pLiteral$HexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pLiteral$HexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = "\\"+a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pLiteral$HexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pLiteral$HexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyResult = pLiteral$HexDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a4 = yyResult.semanticValue();

            yyResult = pLiteral$HexDigit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a5 = yyResult.semanticValue();

              yyValue = "\\"+a1+a2+a3+a4+a5;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.EscapeSequence$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeSequence$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pEscapeCharOrLT(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("escape sequence expected", yyStart);
    }

    // Done.
    yyError = yyError.select("escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.EscapeCharOrLT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeCharOrLT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ((('0' <= a1) && (a1 <= '9')) ||
          ('u' == a1) ||
          ('x' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("escape char or l t expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.LineContinuation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineContinuation(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pLineTerminatorSequence(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a1+a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("line continuation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonDoubleStringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonDoubleStringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' == a1) ||
          ('\\' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("non double string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.SingleStringCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleStringCharacter(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pEscapeSequence(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pLineContinuation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSingleStringCharacter$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = a1+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("single string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.SingleStringCharacter$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleStringCharacter$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonSingleStringChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("single string character expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonSingleStringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonSingleStringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\'' == a1) ||
          ('\\' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("non single string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionLiteral(final int yyStart) 
    throws IOException {

    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    RegularExpression yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pRegularExpressionBody(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('/' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pRegularExpressionFlags(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a2 = yyResult.semanticValue();

            Span span = createSpan(yyStart,yyCount);
            yyValue = NodeFactory.makeRegularExpression(span, a1, a2);

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("\"/\" expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("regular expression literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionBody(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRegularExpressionFirstChar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRegularExpressionChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<String> a2s = yyRepValue1.reverse();

        StringBuilder buf = new StringBuilder();
        buf.append(a1);
        for (String s : a2s.list()) buf.append(s);
        yyValue = buf.toString();

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionFirstChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionFirstChar(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRegularExpressionBackslashSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pRegularExpressionFirstChar$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character s = yyResult.semanticValue();

      yyValue = s+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pRegularExpressionClass(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.RegularExpressionFirstChar$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionFirstChar$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonRegularExpressionFirstChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("regular expression first char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("regular expression first char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonRegularExpressionFirstChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonRegularExpressionFirstChar(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("non regular expression first char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionChar(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRegularExpressionBackslashSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pRegularExpressionChar$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character s = yyResult.semanticValue();

      yyValue = s+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pRegularExpressionClass(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.RegularExpressionChar$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionChar$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonRegularExpressionChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("regular expression char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("regular expression char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonRegularExpressionChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonRegularExpressionChar(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("non regular expression char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionBackslashSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionBackslashSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pRegularExpressionNonTerminator(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        yyValue = "\\"+a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("regular expression backslash sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionNonTerminator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionNonTerminator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRegularExpressionNonTerminator$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character s = yyResult.semanticValue();

      yyValue = s+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.RegularExpressionNonTerminator$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionNonTerminator$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = p$$Shared8(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("regular expression non terminator expected", yyStart);
    }

    // Done.
    yyError = yyError.select("regular expression non terminator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionClass.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionClass(final int yyStart) 
    throws IOException {

    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRegularExpressionClassChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a1s.
        Pair<String> a1s = yyRepValue1.reverse();

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if (']' == yyC) {
          yyIndex = yyRepetition1 + 1;

          StringBuilder buf = new StringBuilder();
          buf.append("[");
          for (String s : a1s.list()) buf.append(s);
          buf.append("]");
          yyValue = buf.toString();

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"]\" expected", yyBase);
        }
      } // End scope for a1s.
    }

    // Done.
    yyError = yyError.select("regular expression class expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionClassChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionClassChar(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRegularExpressionBackslashSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pRegularExpressionClassChar$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character s = yyResult.semanticValue();

      yyValue = s+"";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.RegularExpressionClassChar$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionClassChar$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonRegularExpressionClassChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("regular expression class char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("regular expression class char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.NonRegularExpressionClassChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonRegularExpressionClassChar(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ']':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("non regular expression class char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Literal.RegularExpressionFlags.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRegularExpressionFlags(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pidrest(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for a1s.
      Pair<String> a1s = yyRepValue1.reverse();

      StringBuilder buf = new StringBuilder();
      for (String s : a1s.list()) buf.append(s);
      yyValue = buf.toString();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for a1s.
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pid(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      if (!JAVASCRIPT_RESERVED.contains(s)) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared16.
   * This nonterminal represents the duplicate productions 
   * kr.ac.kaist.jsaf.parser.JS.id$$Choice1 
   * and kr.ac.kaist.jsaf.parser.JS.idname$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared16(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidstart(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      while (true) {

        yyResult = pidrest(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idname.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidname(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String s = yyResult.semanticValue();

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idstart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidstart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pUnicodeEscapeSequence(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idstart expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '$':
        {
          yyValue = "$";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = "_";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pUnicodeEscapeSequence(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('\u0300' <= yyC) && (yyC <= '\u036f')) ||
          (('\u0483' <= yyC) && (yyC <= '\u0486')) ||
          (('\u0591' <= yyC) && (yyC <= '\u05bd')) ||
          ('\u05bf' == yyC) ||
          (('\u05c1' <= yyC) && (yyC <= '\u05c2')) ||
          (('\u05c4' <= yyC) && (yyC <= '\u05c5')) ||
          ('\u05c7' == yyC) ||
          (('\u0610' <= yyC) && (yyC <= '\u0615')) ||
          (('\u064b' <= yyC) && (yyC <= '\u065e')) ||
          ('\u0670' == yyC) ||
          (('\u06d6' <= yyC) && (yyC <= '\u06dc')) ||
          (('\u06df' <= yyC) && (yyC <= '\u06e4')) ||
          (('\u06e7' <= yyC) && (yyC <= '\u06e8')) ||
          (('\u06ea' <= yyC) && (yyC <= '\u06ed')) ||
          ('\u0711' == yyC) ||
          (('\u0730' <= yyC) && (yyC <= '\u074a')) ||
          (('\u07a6' <= yyC) && (yyC <= '\u07b0')) ||
          (('\u07eb' <= yyC) && (yyC <= '\u07f3')) ||
          (('\u0901' <= yyC) && (yyC <= '\u0903')) ||
          ('\u093c' == yyC) ||
          (('\u093e' <= yyC) && (yyC <= '\u094d')) ||
          (('\u0951' <= yyC) && (yyC <= '\u0954')) ||
          (('\u0962' <= yyC) && (yyC <= '\u0963')) ||
          (('\u0981' <= yyC) && (yyC <= '\u0983')) ||
          ('\u09bc' == yyC) ||
          (('\u09be' <= yyC) && (yyC <= '\u09c4')) ||
          (('\u09c7' <= yyC) && (yyC <= '\u09c8')) ||
          (('\u09cb' <= yyC) && (yyC <= '\u09cd')) ||
          ('\u09d7' == yyC) ||
          (('\u09e2' <= yyC) && (yyC <= '\u09e3')) ||
          (('\u0a01' <= yyC) && (yyC <= '\u0a03')) ||
          ('\u0a3c' == yyC) ||
          (('\u0a3e' <= yyC) && (yyC <= '\u0a42')) ||
          (('\u0a47' <= yyC) && (yyC <= '\u0a48')) ||
          (('\u0a4b' <= yyC) && (yyC <= '\u0a4d')) ||
          (('\u0a70' <= yyC) && (yyC <= '\u0a71')) ||
          (('\u0a81' <= yyC) && (yyC <= '\u0a83')) ||
          ('\u0abc' == yyC) ||
          (('\u0abe' <= yyC) && (yyC <= '\u0ac5')) ||
          (('\u0ac7' <= yyC) && (yyC <= '\u0ac9')) ||
          (('\u0acb' <= yyC) && (yyC <= '\u0acd')) ||
          (('\u0ae2' <= yyC) && (yyC <= '\u0ae3')) ||
          (('\u0b01' <= yyC) && (yyC <= '\u0b03')) ||
          ('\u0b3c' == yyC) ||
          (('\u0b3e' <= yyC) && (yyC <= '\u0b43')) ||
          (('\u0b47' <= yyC) && (yyC <= '\u0b48')) ||
          (('\u0b4b' <= yyC) && (yyC <= '\u0b4d')) ||
          (('\u0b56' <= yyC) && (yyC <= '\u0b57')) ||
          ('\u0b82' == yyC) ||
          (('\u0bbe' <= yyC) && (yyC <= '\u0bc2')) ||
          (('\u0bc6' <= yyC) && (yyC <= '\u0bc8')) ||
          (('\u0bca' <= yyC) && (yyC <= '\u0bcd')) ||
          ('\u0bd7' == yyC) ||
          (('\u0c01' <= yyC) && (yyC <= '\u0c03')) ||
          (('\u0c3e' <= yyC) && (yyC <= '\u0c44')) ||
          (('\u0c46' <= yyC) && (yyC <= '\u0c48')) ||
          (('\u0c4a' <= yyC) && (yyC <= '\u0c4d')) ||
          (('\u0c55' <= yyC) && (yyC <= '\u0c56')) ||
          (('\u0c82' <= yyC) && (yyC <= '\u0c83')) ||
          ('\u0cbc' == yyC) ||
          (('\u0cbe' <= yyC) && (yyC <= '\u0cc4')) ||
          (('\u0cc6' <= yyC) && (yyC <= '\u0cc8')) ||
          (('\u0cca' <= yyC) && (yyC <= '\u0ccd')) ||
          (('\u0cd5' <= yyC) && (yyC <= '\u0cd6')) ||
          (('\u0ce2' <= yyC) && (yyC <= '\u0ce3')) ||
          (('\u0d02' <= yyC) && (yyC <= '\u0d03')) ||
          (('\u0d3e' <= yyC) && (yyC <= '\u0d43')) ||
          (('\u0d46' <= yyC) && (yyC <= '\u0d48')) ||
          (('\u0d4a' <= yyC) && (yyC <= '\u0d4d')) ||
          ('\u0d57' == yyC) ||
          (('\u0d82' <= yyC) && (yyC <= '\u0d83')) ||
          ('\u0dca' == yyC) ||
          (('\u0dcf' <= yyC) && (yyC <= '\u0dd4')) ||
          ('\u0dd6' == yyC) ||
          (('\u0dd8' <= yyC) && (yyC <= '\u0ddf')) ||
          (('\u0df2' <= yyC) && (yyC <= '\u0df3')) ||
          ('\u0e31' == yyC) ||
          (('\u0e34' <= yyC) && (yyC <= '\u0e3a')) ||
          (('\u0e47' <= yyC) && (yyC <= '\u0e4e')) ||
          ('\u0eb1' == yyC) ||
          (('\u0eb4' <= yyC) && (yyC <= '\u0eb9')) ||
          (('\u0ebb' <= yyC) && (yyC <= '\u0ebc')) ||
          (('\u0ec8' <= yyC) && (yyC <= '\u0ecd')) ||
          (('\u0f18' <= yyC) && (yyC <= '\u0f19')) ||
          ('\u0f35' == yyC) ||
          ('\u0f37' == yyC) ||
          ('\u0f39' == yyC) ||
          (('\u0f3e' <= yyC) && (yyC <= '\u0f3f')) ||
          (('\u0f71' <= yyC) && (yyC <= '\u0f84')) ||
          (('\u0f86' <= yyC) && (yyC <= '\u0f87')) ||
          (('\u0f90' <= yyC) && (yyC <= '\u0f97')) ||
          (('\u0f99' <= yyC) && (yyC <= '\u0fbc')) ||
          ('\u0fc6' == yyC) ||
          (('\u102c' <= yyC) && (yyC <= '\u1032')) ||
          (('\u1036' <= yyC) && (yyC <= '\u1039')) ||
          (('\u1056' <= yyC) && (yyC <= '\u1059')) ||
          ('\u135f' == yyC) ||
          (('\u1712' <= yyC) && (yyC <= '\u1714')) ||
          (('\u1732' <= yyC) && (yyC <= '\u1734')) ||
          (('\u1752' <= yyC) && (yyC <= '\u1753')) ||
          (('\u1772' <= yyC) && (yyC <= '\u1773')) ||
          (('\u17b6' <= yyC) && (yyC <= '\u17d3')) ||
          ('\u17dd' == yyC) ||
          (('\u180b' <= yyC) && (yyC <= '\u180d')) ||
          ('\u18a9' == yyC) ||
          (('\u1920' <= yyC) && (yyC <= '\u192b')) ||
          (('\u1930' <= yyC) && (yyC <= '\u193b')) ||
          (('\u19b0' <= yyC) && (yyC <= '\u19c0')) ||
          (('\u19c8' <= yyC) && (yyC <= '\u19c9')) ||
          (('\u1a17' <= yyC) && (yyC <= '\u1a1b')) ||
          (('\u1b00' <= yyC) && (yyC <= '\u1b04')) ||
          (('\u1b34' <= yyC) && (yyC <= '\u1b44')) ||
          (('\u1b6b' <= yyC) && (yyC <= '\u1b73')) ||
          (('\u1dc0' <= yyC) && (yyC <= '\u1dca')) ||
          (('\u1dfe' <= yyC) && (yyC <= '\u1dff')) ||
          (('\u20d0' <= yyC) && (yyC <= '\u20dc')) ||
          ('\u20e1' == yyC) ||
          (('\u20e5' <= yyC) && (yyC <= '\u20ef')) ||
          (('\u302a' <= yyC) && (yyC <= '\u302f')) ||
          (('\u3099' <= yyC) && (yyC <= '\u309a')) ||
          ('\ua802' == yyC) ||
          ('\ua806' == yyC) ||
          ('\ua80b' == yyC) ||
          (('\ua823' <= yyC) && (yyC <= '\ua827')) ||
          ('\ufb1e' == yyC) ||
          (('\ufe00' <= yyC) && (yyC <= '\ufe0f')) ||
          (('\ufe20' <= yyC) && (yyC <= '\ufe23'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\ude01':
            case '\ude02':
            case '\ude03':
            case '\ude05':
            case '\ude06':
            case '\ude0c':
            case '\ude0d':
            case '\ude0e':
            case '\ude0f':
            case '\ude38':
            case '\ude39':
            case '\ude3a':
            case '\ude3f':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud834':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udd65' <= yyC) && (yyC <= '\udd69')) ||
                (('\udd6d' <= yyC) && (yyC <= '\udd72')) ||
                (('\udd7b' <= yyC) && (yyC <= '\udd82')) ||
                (('\udd85' <= yyC) && (yyC <= '\udd8b')) ||
                (('\uddaa' <= yyC) && (yyC <= '\uddad')) ||
                (('\ude42' <= yyC) && (yyC <= '\ude44'))) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\udb40':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udd00' <= yyC) && (yyC <= '\uddef')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('\u0660' <= yyC) && (yyC <= '\u0669')) ||
          (('\u06f0' <= yyC) && (yyC <= '\u06f9')) ||
          (('\u07c0' <= yyC) && (yyC <= '\u07c9')) ||
          (('\u0966' <= yyC) && (yyC <= '\u096f')) ||
          (('\u09e6' <= yyC) && (yyC <= '\u09ef')) ||
          (('\u0a66' <= yyC) && (yyC <= '\u0a6f')) ||
          (('\u0ae6' <= yyC) && (yyC <= '\u0aef')) ||
          (('\u0b66' <= yyC) && (yyC <= '\u0b6f')) ||
          (('\u0be6' <= yyC) && (yyC <= '\u0bef')) ||
          (('\u0c66' <= yyC) && (yyC <= '\u0c6f')) ||
          (('\u0ce6' <= yyC) && (yyC <= '\u0cef')) ||
          (('\u0d66' <= yyC) && (yyC <= '\u0d6f')) ||
          (('\u0e50' <= yyC) && (yyC <= '\u0e59')) ||
          (('\u0ed0' <= yyC) && (yyC <= '\u0ed9')) ||
          (('\u0f20' <= yyC) && (yyC <= '\u0f29')) ||
          (('\u1040' <= yyC) && (yyC <= '\u1049')) ||
          (('\u17e0' <= yyC) && (yyC <= '\u17e9')) ||
          (('\u1810' <= yyC) && (yyC <= '\u1819')) ||
          (('\u1946' <= yyC) && (yyC <= '\u194f')) ||
          (('\u19d0' <= yyC) && (yyC <= '\u19d9')) ||
          (('\u1b50' <= yyC) && (yyC <= '\u1b59')) ||
          (('\uff10' <= yyC) && (yyC <= '\uff19'))) {

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 6.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '\udca0':
            case '\udca1':
            case '\udca2':
            case '\udca3':
            case '\udca4':
            case '\udca5':
            case '\udca6':
            case '\udca7':
            case '\udca8':
            case '\udca9':
              {
                yyValue = difference(yyStart, yyIndex);

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udfce' <= yyC) && (yyC <= '\udfff')) {

              yyValue = difference(yyStart, yyIndex);

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '_':
      case '\u203f':
      case '\u2040':
      case '\u2054':
      case '\ufe33':
      case '\ufe34':
      case '\ufe4d':
      case '\ufe4e':
      case '\ufe4f':
      case '\uff3f':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u200c':
      case '\u200d':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.UnicodeEscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeEscapeSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pIdentifier$HexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pIdentifier$HexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pIdentifier$HexDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pIdentifier$HexDigit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unicode escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.HexDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier$HexDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdText(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pid(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdTextName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdTextName(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pidname(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Id.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pId(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fId) yyColumn.chunk4.fId = pId$1(yyStart);
    return yyColumn.chunk4.fId;
  }

  /** Actually parse Identifier.Id. */
  private Result pId$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('_' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('I' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('S' == yyC) {
                          yyIndex = yyIndex + 1;
                          String a1 = "_<>_printIS";

                          yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount+1), a1);

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('_' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('p' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('r' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('i' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('t' == yyC) {
                      yyIndex = yyIndex + 1;
                      String a1 = "_<>_print";

                      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount+1), a1);

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('_' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('g' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('T' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('i' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('c' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyC = character(yyIndex);
                        if ('k' == yyC) {
                          yyIndex = yyIndex + 1;

                          yyC = character(yyIndex);
                          if ('C' == yyC) {
                            yyIndex = yyIndex + 1;

                            yyC = character(yyIndex);
                            if ('o' == yyC) {
                              yyIndex = yyIndex + 1;

                              yyC = character(yyIndex);
                              if ('u' == yyC) {
                                yyIndex = yyIndex + 1;

                                yyC = character(yyIndex);
                                if ('n' == yyC) {
                                  yyIndex = yyIndex + 1;

                                  yyC = character(yyIndex);
                                  if ('t' == yyC) {
                                    yyIndex = yyIndex + 1;
                                    String a1 = "_<>_getTickCount";

                                    yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount+1), a1);

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pIdText(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("id expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.IdName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdName(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIdName) 
      yyColumn.chunk4.fIdName = pIdName$1(yyStart);
    return yyColumn.chunk4.fIdName;
  }

  /** Actually parse Identifier.IdName. */
  private Result pIdName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Id         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdTextName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeId(createSpan(yyStart,yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Path.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPath(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fPath) 
      yyColumn.chunk4.fPath = pPath$1(yyStart);
    return yyColumn.chunk4.fPath;
  }

  /** Actually parse Identifier.Path. */
  private Result pPath$1(final int yyStart) throws IOException {
    Result     yyResult;
    Path       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPath$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Pair<Id> a1s = yyResult.semanticValue();

      yyResult = pId(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Id a2 = yyResult.semanticValue();

        List<Id> ids = new ArrayList<Id>();
        if (a1s != null) ids.addAll(a1s.list());
        ids.add(a2);
        yyValue = NodeFactory.makePath(createSpan(yyStart,yyCount), ids);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.Path$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPath$$Star1(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fPath$$Star1) 
      yyColumn.chunk4.fPath$$Star1 = pPath$$Star1$1(yyStart);
    return yyColumn.chunk4.fPath$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.JS.Path$$Star1. */
  private Result pPath$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Id>   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pId(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Id v$el$1 = yyResult.semanticValue();

      yyResult = pdot(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pPath$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Pair<Id> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Id>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.semicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result psemicolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (';' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.colon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcolon(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (':' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("colon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.openparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popenparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('(' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("openparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closeparen.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcloseparen(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (')' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closeparen expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opencurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popencurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opencurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closecurly.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosecurly(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('}' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closecurly expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.opensquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result popensquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("opensquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.closesquare.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pclosesquare(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("closesquare expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.dot.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdot(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = ".";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("dot expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.comma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcomma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = ",";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("comma expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.star.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pstar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.question.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pquestion(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('?' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("question expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.and.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pand(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fand) yyColumn.chunk4.fand = pand$1(yyStart);
    return yyColumn.chunk4.fand;
  }

  /** Actually parse Symbol.and. */
  private Result pand$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pand$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "&");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("and expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("and expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.and$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pand$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '&':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("and expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ands.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pands(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fands) 
      yyColumn.chunk4.fands = pands$1(yyStart);
    return yyColumn.chunk4.fands;
  }

  /** Actually parse Symbol.ands. */
  private Result pands$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "&&");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ands expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbar(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fbar) yyColumn.chunk4.fbar = pbar$1(yyStart);
    return yyColumn.chunk4.fbar;
  }

  /** Actually parse Symbol.bar. */
  private Result pbar$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pbar$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "|");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("bar expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.bar$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbar$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '|':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("bar expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbars(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fbars) 
      yyColumn.chunk4.fbars = pbars$1(yyStart);
    return yyColumn.chunk4.fbars;
  }

  /** Actually parse Symbol.bars. */
  private Result pbars$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "||");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.caret.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcaret(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fcaret) 
      yyColumn.chunk4.fcaret = pcaret$1(yyStart);
    return yyColumn.chunk4.fcaret;
  }

  /** Actually parse Symbol.caret. */
  private Result pcaret$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "^");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("caret expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("caret expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.equals.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pequals(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fequals) 
      yyColumn.chunk4.fequals = pequals$1(yyStart);
    return yyColumn.chunk4.fequals;
  }

  /** Actually parse Symbol.equals. */
  private Result pequals$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "=");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("equals expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("equals expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doubleplus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoubleplus(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fdoubleplus) 
      yyColumn.chunk5.fdoubleplus = pdoubleplus$1(yyStart);
    return yyColumn.chunk5.fdoubleplus;
  }

  /** Actually parse Symbol.doubleplus. */
  private Result pdoubleplus$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('+' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "++");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("doubleplus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.doubleminus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdoubleminus(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fdoubleminus) 
      yyColumn.chunk5.fdoubleminus = pdoubleminus$1(yyStart);
    return yyColumn.chunk5.fdoubleminus;
  }

  /** Actually parse Symbol.doubleminus. */
  private Result pdoubleminus$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('-' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "--");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("doubleminus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.plus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplus(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fplus) 
      yyColumn.chunk5.fplus = pplus$1(yyStart);
    return yyColumn.chunk5.fplus;
  }

  /** Actually parse Symbol.plus. */
  private Result pplus$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pplus$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "+");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("plus expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.plus$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pplus$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '+':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("plus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.minus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fminus) 
      yyColumn.chunk5.fminus = pminus$1(yyStart);
    return yyColumn.chunk5.fminus;
  }

  /** Actually parse Symbol.minus. */
  private Result pminus$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyPredResult = pminus$$Choice1(yyIndex);
      if (yyPredResult.hasValue()) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "-");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("minus expected", yyStart);
      }
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.minus$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pminus$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.tilde.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptilde(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('~' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "~");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("tilde expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.bang.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbang(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "!");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("bang expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AssignmentOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentOp(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fAssignmentOp) 
      yyColumn.chunk5.fAssignmentOp = pAssignmentOp$1(yyStart);
    return yyColumn.chunk5.fAssignmentOp;
  }

  /** Actually parse Symbol.AssignmentOp. */
  private Result pAssignmentOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssignmentOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pequals(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1+"=");

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.AssignmentOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentOp$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "*";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "/";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "%";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "+";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "-";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 6.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 7.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = ">>>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 8.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 9.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "&";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 10.

    yyC = character(yyStart);
    if ('^' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "^";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 11.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "|";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("assignment op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.EqualityOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOp(final int yyStart) throws IOException {
    JSColumn yyColumn = (JSColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fEqualityOp) 
      yyColumn.chunk5.fEqualityOp = pEqualityOp$1(yyStart);
    return yyColumn.chunk5.fEqualityOp;
  }

  /** Actually parse Symbol.EqualityOp. */
  private Result pEqualityOp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEqualityOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.EqualityOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('=' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "===";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('=' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "!==";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "==";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('!' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "!=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("equality op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.RelationalOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelationalOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.RelationalOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOp$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ">";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('i' == yyC) {

        yyC = character(yyIndex);
        if (-1 != yyC) {
          yyIndex = yyIndex + 1;
          if ('n' == yyC) {

            final int yyChoice1 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;
              if ('s' == yyC) {

                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('t' == yyC) {

                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;
                      if ('a' == yyC) {

                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;
                          if ('n' == yyC) {

                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;
                              if ('c' == yyC) {

                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;
                                  if ('e' == yyC) {

                                    yyC = character(yyIndex);
                                    if (-1 != yyC) {
                                      yyIndex = yyIndex + 1;
                                      if ('o' == yyC) {

                                        yyC = character(yyIndex);
                                        if (-1 != yyC) {
                                          yyIndex = yyIndex + 1;
                                          if ('f' == yyC) {

                                            yyPredMatched = false;

                                            yyPredResult = pidrest(yyIndex);
                                            if (yyPredResult.hasValue()) {

                                              yyPredMatched = true;
                                            }

                                            if (! yyPredMatched) {

                                              yyValue = "instanceof";

                                              return new SemanticValue(yyValue, yyIndex, yyError);
                                            } else {
                                              yyError = yyError.select("relational op expected", yyStart);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            // Nested alternative 2.

            yyPredMatched = false;

            yyPredResult = pidrest(yyChoice1);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = "in";

              return new SemanticValue(yyValue, yyChoice1, yyError);
            } else {
              yyError = yyError.select("relational op expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("relational op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.RelationalOpNoIn.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOpNoIn(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRelationalOpNoIn$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.RelationalOpNoIn$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOpNoIn$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">=";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "<";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = ">";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('a' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('c' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyC = character(yyIndex);
                    if ('o' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyC = character(yyIndex);
                      if ('f' == yyC) {
                        yyIndex = yyIndex + 1;

                        yyPredMatched = false;

                        yyPredResult = pidrest(yyIndex);
                        if (yyPredResult.hasValue()) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyValue = "instanceof";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        } else {
                          yyError = yyError.select("relational op no in expected", yyStart);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("relational op no in expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.ShiftOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOp(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pShiftOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("shift op expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.ShiftOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOp$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('<' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "<<";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = ">>>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('>' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('>' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = ">>";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("shift op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.AdditiveOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOp(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAdditiveOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.AdditiveOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOp$$Choice1(final int yyStart) throws IOException {
    Result     yyResult;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pplus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pminus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.MultiplicativeOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOp(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMultiplicativeOp$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if ('=' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), a1);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("multiplicative op expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.MultiplicativeOp$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOp$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "*";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "/";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('%' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "%";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("multiplicative op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('\u001a' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    } else {
      yyError = yyError.select("\"\\u001a\" expected", yyBase);
    }

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if (-1 != yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("end of file expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EOS.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOS(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyResult.index + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\";\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pLineTerminatorSequence(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyPredResult = ps(yyStart);
    yyError      = yyPredResult.select(yyError);
    if (yyPredResult.hasValue()) {

      yyBase = yyPredResult.index;
      yyC    = character(yyBase);
      if ('}' == yyC) {

        yyResult = ps(yyStart);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"}\" expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pw(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEndOfFile(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EOSnoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEOSnoLB(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if (';' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\";\" expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pLineTerminatorSequence(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyPredResult = ps(yyStart);
    yyError      = yyPredResult.select(yyError);
    if (yyPredResult.hasValue()) {

      yyBase = yyPredResult.index;
      yyC    = character(yyBase);
      if ('}' == yyC) {

        yyResult = ps(yyStart);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("\"}\" expected", yyBase);
      }
    }

    // Alternative 3.

    yyResult = ps(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pEndOfFile(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('/' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentWLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentWLB(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentCharNoLB(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyResult = p$$Shared8(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyResult = pMultiLineCommentCharWLB(yyRepetition1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                String v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<String>(v$el$2, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for a3s.
              Pair<String> a3s = yyRepValue1.reverse();

              yyBase = yyRepetition1;
              yyC    = character(yyBase);
              if ('*' == yyC) {
                yyIndex = yyRepetition1 + 1;

                yyC = character(yyIndex);
                if ('/' == yyC) {
                  yyIndex = yyIndex + 1;

                  StringBuilder buf = new StringBuilder();
                  buf.append("/*");
                  for (String s : a1s.list()) buf.append(s);
                  buf.append(a2);
                  for (String s : a3s.list()) buf.append(s);
                  buf.append("*/");
                  yyValue = buf.toString();
                  NodeFactory.commentLog(createSpan(yyStart,yyCount+1), yyValue);

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("\"*/\" expected", yyBase);
                }
              } else {
                yyError = yyError.select("\"*/\" expected", yyBase);
              }
            } // End scope for a3s.
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("multi line comment w l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentCharWLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharWLB(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyPredIndex;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyPredIndex = yyStart + 1;

      yyC = character(yyPredIndex);
      if ('/' == yyC) {

        yyPredMatched = true;
      }
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char w l b expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char w l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentNoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentNoLB(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    String       yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentCharNoLB(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              StringBuilder buf = new StringBuilder();
              buf.append("/*");
              for (String s : a1s.list()) buf.append(s);
              buf.append("*/");
              yyValue = buf.toString();
              NodeFactory.commentLog(createSpan(yyStart,yyCount+1), yyValue);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*/\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*/\" expected", yyBase);
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("multi line comment no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.MultiLineCommentCharNoLB.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharNoLB(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pMultiLineCommentCharNoLB$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("multi line comment char no l b expected", yyStart);
    }

    // Done.
    yyError = yyError.select("multi line comment char no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.MultiLineCommentCharNoLB$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiLineCommentCharNoLB$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('*' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("multi line comment char no l b expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.SingleLineComment$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleLineComment$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;
        yyValue = "//";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('!' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('-' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('-' == yyC) {
            yyIndex = yyIndex + 1;
            yyValue = "<!--";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("single line comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.SingleLineCommentChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSingleLineCommentChar(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = p$$Shared8(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        char a1 = (char)yyC;

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("single line comment char expected", yyStart);
    }

    // Done.
    yyError = yyError.select("single line comment char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.$$Shared8.
   * This nonterminal represents the duplicate productions 
   * Spacing.LineTerminatorChar and Spacing.LineTerminatorNoMC.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared8(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared8$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = ""+a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.$$Shared8$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared8$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2028' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if ('\u2029' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.LineTerminatorSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminatorSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLineTerminatorSequence$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = ""+a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if ('\n' == yyC) {
        yyIndex = yyChoice1 + 1;
        char a2 = (char)yyC;

        yyValue = ""+a1+a2;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }

      // Nested alternative 2.

      yyPredMatched = false;

      yyC = character(yyChoice1);
      if ('\n' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = ""+a1;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("line terminator sequence expected", yyStart);
      }
    }

    // Alternative 3.

    yyResult = pMultiLineCommentWLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.JS.LineTerminatorSequence$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminatorSequence$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\n' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\u2028' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\u2029' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("line terminator sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Result       yyPredResult;
    boolean      yyPredMatched;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Void         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u000b':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u3000':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u00a0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\ufeff':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('>' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pSpace$$Choice1(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("space expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 6.

    yyResult = pSingleLineComment$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSingleLineCommentChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<String> a2s = yyRepValue1.reverse();

        StringBuilder buf = new StringBuilder();
        buf.append(a1);
        for (String s : a2s.list()) buf.append(s);
        NodeFactory.commentLog(createSpan(yyStart,yyCount), buf.toString());

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 7.

    yyResult = pMultiLineCommentNoLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal kr.ac.kaist.jsaf.parser.JS.Space$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z')) ||
          ('\u00aa' == yyC) ||
          ('\u00b5' == yyC) ||
          ('\u00ba' == yyC) ||
          (('\u00c0' <= yyC) && (yyC <= '\u00d6')) ||
          (('\u00d8' <= yyC) && (yyC <= '\u00f6')) ||
          (('\u00f8' <= yyC) && (yyC <= '\u02c1')) ||
          (('\u02c6' <= yyC) && (yyC <= '\u02d1')) ||
          (('\u02e0' <= yyC) && (yyC <= '\u02e4')) ||
          ('\u02ee' == yyC) ||
          (('\u037a' <= yyC) && (yyC <= '\u037d')) ||
          ('\u0386' == yyC) ||
          (('\u0388' <= yyC) && (yyC <= '\u038a')) ||
          ('\u038c' == yyC) ||
          (('\u038e' <= yyC) && (yyC <= '\u03a1')) ||
          (('\u03a3' <= yyC) && (yyC <= '\u03ce')) ||
          (('\u03d0' <= yyC) && (yyC <= '\u03f5')) ||
          (('\u03f7' <= yyC) && (yyC <= '\u0481')) ||
          (('\u048a' <= yyC) && (yyC <= '\u0513')) ||
          (('\u0531' <= yyC) && (yyC <= '\u0556')) ||
          ('\u0559' == yyC) ||
          (('\u0561' <= yyC) && (yyC <= '\u0587')) ||
          (('\u05d0' <= yyC) && (yyC <= '\u05ea')) ||
          (('\u05f0' <= yyC) && (yyC <= '\u05f2')) ||
          (('\u0621' <= yyC) && (yyC <= '\u063a')) ||
          (('\u0640' <= yyC) && (yyC <= '\u064a')) ||
          (('\u066e' <= yyC) && (yyC <= '\u066f')) ||
          (('\u0671' <= yyC) && (yyC <= '\u06d3')) ||
          ('\u06d5' == yyC) ||
          (('\u06e5' <= yyC) && (yyC <= '\u06e6')) ||
          (('\u06ee' <= yyC) && (yyC <= '\u06ef')) ||
          (('\u06fa' <= yyC) && (yyC <= '\u06fc')) ||
          ('\u06ff' == yyC) ||
          ('\u0710' == yyC) ||
          (('\u0712' <= yyC) && (yyC <= '\u072f')) ||
          (('\u074d' <= yyC) && (yyC <= '\u076d')) ||
          (('\u0780' <= yyC) && (yyC <= '\u07a5')) ||
          ('\u07b1' == yyC) ||
          (('\u07ca' <= yyC) && (yyC <= '\u07ea')) ||
          (('\u07f4' <= yyC) && (yyC <= '\u07f5')) ||
          ('\u07fa' == yyC) ||
          (('\u0904' <= yyC) && (yyC <= '\u0939')) ||
          ('\u093d' == yyC) ||
          ('\u0950' == yyC) ||
          (('\u0958' <= yyC) && (yyC <= '\u0961')) ||
          (('\u097b' <= yyC) && (yyC <= '\u097f')) ||
          (('\u0985' <= yyC) && (yyC <= '\u098c')) ||
          (('\u098f' <= yyC) && (yyC <= '\u0990')) ||
          (('\u0993' <= yyC) && (yyC <= '\u09a8')) ||
          (('\u09aa' <= yyC) && (yyC <= '\u09b0')) ||
          ('\u09b2' == yyC) ||
          (('\u09b6' <= yyC) && (yyC <= '\u09b9')) ||
          ('\u09bd' == yyC) ||
          ('\u09ce' == yyC) ||
          (('\u09dc' <= yyC) && (yyC <= '\u09dd')) ||
          (('\u09df' <= yyC) && (yyC <= '\u09e1')) ||
          (('\u09f0' <= yyC) && (yyC <= '\u09f1')) ||
          (('\u0a05' <= yyC) && (yyC <= '\u0a0a')) ||
          (('\u0a0f' <= yyC) && (yyC <= '\u0a10')) ||
          (('\u0a13' <= yyC) && (yyC <= '\u0a28')) ||
          (('\u0a2a' <= yyC) && (yyC <= '\u0a30')) ||
          (('\u0a32' <= yyC) && (yyC <= '\u0a33')) ||
          (('\u0a35' <= yyC) && (yyC <= '\u0a36')) ||
          (('\u0a38' <= yyC) && (yyC <= '\u0a39')) ||
          (('\u0a59' <= yyC) && (yyC <= '\u0a5c')) ||
          ('\u0a5e' == yyC) ||
          (('\u0a72' <= yyC) && (yyC <= '\u0a74')) ||
          (('\u0a85' <= yyC) && (yyC <= '\u0a8d')) ||
          (('\u0a8f' <= yyC) && (yyC <= '\u0a91')) ||
          (('\u0a93' <= yyC) && (yyC <= '\u0aa8')) ||
          (('\u0aaa' <= yyC) && (yyC <= '\u0ab0')) ||
          (('\u0ab2' <= yyC) && (yyC <= '\u0ab3')) ||
          (('\u0ab5' <= yyC) && (yyC <= '\u0ab9')) ||
          ('\u0abd' == yyC) ||
          ('\u0ad0' == yyC) ||
          (('\u0ae0' <= yyC) && (yyC <= '\u0ae1')) ||
          (('\u0b05' <= yyC) && (yyC <= '\u0b0c')) ||
          (('\u0b0f' <= yyC) && (yyC <= '\u0b10')) ||
          (('\u0b13' <= yyC) && (yyC <= '\u0b28')) ||
          (('\u0b2a' <= yyC) && (yyC <= '\u0b30')) ||
          (('\u0b32' <= yyC) && (yyC <= '\u0b33')) ||
          (('\u0b35' <= yyC) && (yyC <= '\u0b39')) ||
          ('\u0b3d' == yyC) ||
          (('\u0b5c' <= yyC) && (yyC <= '\u0b5d')) ||
          (('\u0b5f' <= yyC) && (yyC <= '\u0b61')) ||
          ('\u0b71' == yyC) ||
          ('\u0b83' == yyC) ||
          (('\u0b85' <= yyC) && (yyC <= '\u0b8a')) ||
          (('\u0b8e' <= yyC) && (yyC <= '\u0b90')) ||
          (('\u0b92' <= yyC) && (yyC <= '\u0b95')) ||
          (('\u0b99' <= yyC) && (yyC <= '\u0b9a')) ||
          ('\u0b9c' == yyC) ||
          (('\u0b9e' <= yyC) && (yyC <= '\u0b9f')) ||
          (('\u0ba3' <= yyC) && (yyC <= '\u0ba4')) ||
          (('\u0ba8' <= yyC) && (yyC <= '\u0baa')) ||
          (('\u0bae' <= yyC) && (yyC <= '\u0bb9')) ||
          (('\u0c05' <= yyC) && (yyC <= '\u0c0c')) ||
          (('\u0c0e' <= yyC) && (yyC <= '\u0c10')) ||
          (('\u0c12' <= yyC) && (yyC <= '\u0c28')) ||
          (('\u0c2a' <= yyC) && (yyC <= '\u0c33')) ||
          (('\u0c35' <= yyC) && (yyC <= '\u0c39')) ||
          (('\u0c60' <= yyC) && (yyC <= '\u0c61')) ||
          (('\u0c85' <= yyC) && (yyC <= '\u0c8c')) ||
          (('\u0c8e' <= yyC) && (yyC <= '\u0c90')) ||
          (('\u0c92' <= yyC) && (yyC <= '\u0ca8')) ||
          (('\u0caa' <= yyC) && (yyC <= '\u0cb3')) ||
          (('\u0cb5' <= yyC) && (yyC <= '\u0cb9')) ||
          ('\u0cbd' == yyC) ||
          ('\u0cde' == yyC) ||
          (('\u0ce0' <= yyC) && (yyC <= '\u0ce1')) ||
          (('\u0d05' <= yyC) && (yyC <= '\u0d0c')) ||
          (('\u0d0e' <= yyC) && (yyC <= '\u0d10')) ||
          (('\u0d12' <= yyC) && (yyC <= '\u0d28')) ||
          (('\u0d2a' <= yyC) && (yyC <= '\u0d39')) ||
          (('\u0d60' <= yyC) && (yyC <= '\u0d61')) ||
          (('\u0d85' <= yyC) && (yyC <= '\u0d96')) ||
          (('\u0d9a' <= yyC) && (yyC <= '\u0db1')) ||
          (('\u0db3' <= yyC) && (yyC <= '\u0dbb')) ||
          ('\u0dbd' == yyC) ||
          (('\u0dc0' <= yyC) && (yyC <= '\u0dc6')) ||
          (('\u0e01' <= yyC) && (yyC <= '\u0e30')) ||
          (('\u0e32' <= yyC) && (yyC <= '\u0e33')) ||
          (('\u0e40' <= yyC) && (yyC <= '\u0e46')) ||
          (('\u0e81' <= yyC) && (yyC <= '\u0e82')) ||
          ('\u0e84' == yyC) ||
          (('\u0e87' <= yyC) && (yyC <= '\u0e88')) ||
          ('\u0e8a' == yyC) ||
          ('\u0e8d' == yyC) ||
          (('\u0e94' <= yyC) && (yyC <= '\u0e97')) ||
          (('\u0e99' <= yyC) && (yyC <= '\u0e9f')) ||
          (('\u0ea1' <= yyC) && (yyC <= '\u0ea3')) ||
          ('\u0ea5' == yyC) ||
          ('\u0ea7' == yyC) ||
          (('\u0eaa' <= yyC) && (yyC <= '\u0eab')) ||
          (('\u0ead' <= yyC) && (yyC <= '\u0eb0')) ||
          (('\u0eb2' <= yyC) && (yyC <= '\u0eb3')) ||
          ('\u0ebd' == yyC) ||
          (('\u0ec0' <= yyC) && (yyC <= '\u0ec4')) ||
          ('\u0ec6' == yyC) ||
          (('\u0edc' <= yyC) && (yyC <= '\u0edd')) ||
          ('\u0f00' == yyC) ||
          (('\u0f40' <= yyC) && (yyC <= '\u0f47')) ||
          (('\u0f49' <= yyC) && (yyC <= '\u0f6a')) ||
          (('\u0f88' <= yyC) && (yyC <= '\u0f8b')) ||
          (('\u1000' <= yyC) && (yyC <= '\u1021')) ||
          (('\u1023' <= yyC) && (yyC <= '\u1027')) ||
          (('\u1029' <= yyC) && (yyC <= '\u102a')) ||
          (('\u1050' <= yyC) && (yyC <= '\u1055')) ||
          (('\u10a0' <= yyC) && (yyC <= '\u10c5')) ||
          (('\u10d0' <= yyC) && (yyC <= '\u10fa')) ||
          ('\u10fc' == yyC) ||
          (('\u1100' <= yyC) && (yyC <= '\u1159')) ||
          (('\u115f' <= yyC) && (yyC <= '\u11a2')) ||
          (('\u11a8' <= yyC) && (yyC <= '\u11f9')) ||
          (('\u1200' <= yyC) && (yyC <= '\u1248')) ||
          (('\u124a' <= yyC) && (yyC <= '\u124d')) ||
          (('\u1250' <= yyC) && (yyC <= '\u1256')) ||
          ('\u1258' == yyC) ||
          (('\u125a' <= yyC) && (yyC <= '\u125d')) ||
          (('\u1260' <= yyC) && (yyC <= '\u1288')) ||
          (('\u128a' <= yyC) && (yyC <= '\u128d')) ||
          (('\u1290' <= yyC) && (yyC <= '\u12b0')) ||
          (('\u12b2' <= yyC) && (yyC <= '\u12b5')) ||
          (('\u12b8' <= yyC) && (yyC <= '\u12be')) ||
          ('\u12c0' == yyC) ||
          (('\u12c2' <= yyC) && (yyC <= '\u12c5')) ||
          (('\u12c8' <= yyC) && (yyC <= '\u12d6')) ||
          (('\u12d8' <= yyC) && (yyC <= '\u1310')) ||
          (('\u1312' <= yyC) && (yyC <= '\u1315')) ||
          (('\u1318' <= yyC) && (yyC <= '\u135a')) ||
          (('\u1380' <= yyC) && (yyC <= '\u138f')) ||
          (('\u13a0' <= yyC) && (yyC <= '\u13f4')) ||
          (('\u1401' <= yyC) && (yyC <= '\u166c')) ||
          (('\u166f' <= yyC) && (yyC <= '\u1676')) ||
          (('\u1681' <= yyC) && (yyC <= '\u169a')) ||
          (('\u16a0' <= yyC) && (yyC <= '\u16ea')) ||
          (('\u16ee' <= yyC) && (yyC <= '\u16f0')) ||
          (('\u1700' <= yyC) && (yyC <= '\u170c')) ||
          (('\u170e' <= yyC) && (yyC <= '\u1711')) ||
          (('\u1720' <= yyC) && (yyC <= '\u1731')) ||
          (('\u1740' <= yyC) && (yyC <= '\u1751')) ||
          (('\u1760' <= yyC) && (yyC <= '\u176c')) ||
          (('\u176e' <= yyC) && (yyC <= '\u1770')) ||
          (('\u1780' <= yyC) && (yyC <= '\u17b3')) ||
          ('\u17d7' == yyC) ||
          ('\u17dc' == yyC) ||
          (('\u1820' <= yyC) && (yyC <= '\u1877')) ||
          (('\u1880' <= yyC) && (yyC <= '\u18a8')) ||
          (('\u1900' <= yyC) && (yyC <= '\u191c')) ||
          (('\u1950' <= yyC) && (yyC <= '\u196d')) ||
          (('\u1970' <= yyC) && (yyC <= '\u1974')) ||
          (('\u1980' <= yyC) && (yyC <= '\u19a9')) ||
          (('\u19c1' <= yyC) && (yyC <= '\u19c7')) ||
          (('\u1a00' <= yyC) && (yyC <= '\u1a16')) ||
          (('\u1b05' <= yyC) && (yyC <= '\u1b33')) ||
          (('\u1b45' <= yyC) && (yyC <= '\u1b4b')) ||
          (('\u1d00' <= yyC) && (yyC <= '\u1dbf')) ||
          (('\u1e00' <= yyC) && (yyC <= '\u1e9b')) ||
          (('\u1ea0' <= yyC) && (yyC <= '\u1ef9')) ||
          (('\u1f00' <= yyC) && (yyC <= '\u1f15')) ||
          (('\u1f18' <= yyC) && (yyC <= '\u1f1d')) ||
          (('\u1f20' <= yyC) && (yyC <= '\u1f45')) ||
          (('\u1f48' <= yyC) && (yyC <= '\u1f4d')) ||
          (('\u1f50' <= yyC) && (yyC <= '\u1f57')) ||
          ('\u1f59' == yyC) ||
          ('\u1f5b' == yyC) ||
          ('\u1f5d' == yyC) ||
          (('\u1f5f' <= yyC) && (yyC <= '\u1f7d')) ||
          (('\u1f80' <= yyC) && (yyC <= '\u1fb4')) ||
          (('\u1fb6' <= yyC) && (yyC <= '\u1fbc')) ||
          ('\u1fbe' == yyC) ||
          (('\u1fc2' <= yyC) && (yyC <= '\u1fc4')) ||
          (('\u1fc6' <= yyC) && (yyC <= '\u1fcc')) ||
          (('\u1fd0' <= yyC) && (yyC <= '\u1fd3')) ||
          (('\u1fd6' <= yyC) && (yyC <= '\u1fdb')) ||
          (('\u1fe0' <= yyC) && (yyC <= '\u1fec')) ||
          (('\u1ff2' <= yyC) && (yyC <= '\u1ff4')) ||
          (('\u1ff6' <= yyC) && (yyC <= '\u1ffc')) ||
          ('\u2071' == yyC) ||
          ('\u207f' == yyC) ||
          (('\u2090' <= yyC) && (yyC <= '\u2094')) ||
          ('\u2102' == yyC) ||
          ('\u2107' == yyC) ||
          (('\u210a' <= yyC) && (yyC <= '\u2113')) ||
          ('\u2115' == yyC) ||
          (('\u2119' <= yyC) && (yyC <= '\u211d')) ||
          ('\u2124' == yyC) ||
          ('\u2126' == yyC) ||
          ('\u2128' == yyC) ||
          (('\u212a' <= yyC) && (yyC <= '\u212d')) ||
          (('\u212f' <= yyC) && (yyC <= '\u2139')) ||
          (('\u213c' <= yyC) && (yyC <= '\u213f')) ||
          (('\u2145' <= yyC) && (yyC <= '\u2149')) ||
          ('\u214e' == yyC) ||
          (('\u2160' <= yyC) && (yyC <= '\u2184')) ||
          (('\u2c00' <= yyC) && (yyC <= '\u2c2e')) ||
          (('\u2c30' <= yyC) && (yyC <= '\u2c5e')) ||
          (('\u2c60' <= yyC) && (yyC <= '\u2c6c')) ||
          (('\u2c74' <= yyC) && (yyC <= '\u2c77')) ||
          (('\u2c80' <= yyC) && (yyC <= '\u2ce4')) ||
          (('\u2d00' <= yyC) && (yyC <= '\u2d25')) ||
          (('\u2d30' <= yyC) && (yyC <= '\u2d65')) ||
          ('\u2d6f' == yyC) ||
          (('\u2d80' <= yyC) && (yyC <= '\u2d96')) ||
          (('\u2da0' <= yyC) && (yyC <= '\u2da6')) ||
          (('\u2da8' <= yyC) && (yyC <= '\u2dae')) ||
          (('\u2db0' <= yyC) && (yyC <= '\u2db6')) ||
          (('\u2db8' <= yyC) && (yyC <= '\u2dbe')) ||
          (('\u2dc0' <= yyC) && (yyC <= '\u2dc6')) ||
          (('\u2dc8' <= yyC) && (yyC <= '\u2dce')) ||
          (('\u2dd0' <= yyC) && (yyC <= '\u2dd6')) ||
          (('\u2dd8' <= yyC) && (yyC <= '\u2dde')) ||
          (('\u3005' <= yyC) && (yyC <= '\u3007')) ||
          (('\u3021' <= yyC) && (yyC <= '\u3029')) ||
          (('\u3031' <= yyC) && (yyC <= '\u3035')) ||
          (('\u3038' <= yyC) && (yyC <= '\u303c')) ||
          (('\u3041' <= yyC) && (yyC <= '\u3096')) ||
          (('\u309d' <= yyC) && (yyC <= '\u309f')) ||
          (('\u30a1' <= yyC) && (yyC <= '\u30fa')) ||
          (('\u30fc' <= yyC) && (yyC <= '\u30ff')) ||
          (('\u3105' <= yyC) && (yyC <= '\u312c')) ||
          (('\u3131' <= yyC) && (yyC <= '\u318e')) ||
          (('\u31a0' <= yyC) && (yyC <= '\u31b7')) ||
          (('\u31f0' <= yyC) && (yyC <= '\u31ff')) ||
          (('\u3400' <= yyC) && (yyC <= '\u4db5')) ||
          (('\u4e00' <= yyC) && (yyC <= '\u9fbb')) ||
          (('\ua000' <= yyC) && (yyC <= '\ua48c')) ||
          (('\ua717' <= yyC) && (yyC <= '\ua71a')) ||
          (('\ua800' <= yyC) && (yyC <= '\ua801')) ||
          (('\ua803' <= yyC) && (yyC <= '\ua805')) ||
          (('\ua807' <= yyC) && (yyC <= '\ua80a')) ||
          (('\ua80c' <= yyC) && (yyC <= '\ua822')) ||
          (('\ua840' <= yyC) && (yyC <= '\ua873')) ||
          (('\uac00' <= yyC) && (yyC <= '\ud7a3')) ||
          (('\uf900' <= yyC) && (yyC <= '\ufa2d')) ||
          (('\ufa30' <= yyC) && (yyC <= '\ufa6a')) ||
          (('\ufa70' <= yyC) && (yyC <= '\ufad9')) ||
          (('\ufb00' <= yyC) && (yyC <= '\ufb06')) ||
          (('\ufb13' <= yyC) && (yyC <= '\ufb17')) ||
          ('\ufb1d' == yyC) ||
          (('\ufb1f' <= yyC) && (yyC <= '\ufb28')) ||
          (('\ufb2a' <= yyC) && (yyC <= '\ufb36')) ||
          (('\ufb38' <= yyC) && (yyC <= '\ufb3c')) ||
          ('\ufb3e' == yyC) ||
          (('\ufb40' <= yyC) && (yyC <= '\ufb41')) ||
          (('\ufb43' <= yyC) && (yyC <= '\ufb44')) ||
          (('\ufb46' <= yyC) && (yyC <= '\ufbb1')) ||
          (('\ufbd3' <= yyC) && (yyC <= '\ufd3d')) ||
          (('\ufd50' <= yyC) && (yyC <= '\ufd8f')) ||
          (('\ufd92' <= yyC) && (yyC <= '\ufdc7')) ||
          (('\ufdf0' <= yyC) && (yyC <= '\ufdfb')) ||
          (('\ufe70' <= yyC) && (yyC <= '\ufe74')) ||
          (('\ufe76' <= yyC) && (yyC <= '\ufefc')) ||
          (('\uff21' <= yyC) && (yyC <= '\uff3a')) ||
          (('\uff41' <= yyC) && (yyC <= '\uff5a')) ||
          (('\uff66' <= yyC) && (yyC <= '\uffbe')) ||
          (('\uffc2' <= yyC) && (yyC <= '\uffc7')) ||
          (('\uffca' <= yyC) && (yyC <= '\uffcf')) ||
          (('\uffd2' <= yyC) && (yyC <= '\uffd7')) ||
          (('\uffda' <= yyC) && (yyC <= '\uffdc'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\ud800':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc0b')) ||
                (('\udc0d' <= yyC) && (yyC <= '\udc26')) ||
                (('\udc28' <= yyC) && (yyC <= '\udc3a')) ||
                (('\udc3c' <= yyC) && (yyC <= '\udc3d')) ||
                (('\udc3f' <= yyC) && (yyC <= '\udc4d')) ||
                (('\udc50' <= yyC) && (yyC <= '\udc5d')) ||
                (('\udc80' <= yyC) && (yyC <= '\udcfa')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd74')) ||
                (('\udf00' <= yyC) && (yyC <= '\udf1e')) ||
                (('\udf30' <= yyC) && (yyC <= '\udf4a')) ||
                (('\udf80' <= yyC) && (yyC <= '\udf9d')) ||
                (('\udfa0' <= yyC) && (yyC <= '\udfc3')) ||
                (('\udfc8' <= yyC) && (yyC <= '\udfcf')) ||
                (('\udfd1' <= yyC) && (yyC <= '\udfd5'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud801':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc9d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud802':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc05')) ||
                ('\udc08' == yyC) ||
                (('\udc0a' <= yyC) && (yyC <= '\udc35')) ||
                (('\udc37' <= yyC) && (yyC <= '\udc38')) ||
                ('\udc3c' == yyC) ||
                ('\udc3f' == yyC) ||
                (('\udd00' <= yyC) && (yyC <= '\udd15')) ||
                ('\ude00' == yyC) ||
                (('\ude10' <= yyC) && (yyC <= '\ude13')) ||
                (('\ude15' <= yyC) && (yyC <= '\ude17')) ||
                (('\ude19' <= yyC) && (yyC <= '\ude33'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud808':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udf6e')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud809':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\udc62')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud835':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ((('\udc00' <= yyC) && (yyC <= '\udc54')) ||
                (('\udc56' <= yyC) && (yyC <= '\udc9c')) ||
                (('\udc9e' <= yyC) && (yyC <= '\udc9f')) ||
                ('\udca2' == yyC) ||
                (('\udca5' <= yyC) && (yyC <= '\udca6')) ||
                (('\udca9' <= yyC) && (yyC <= '\udcac')) ||
                (('\udcae' <= yyC) && (yyC <= '\udcb9')) ||
                ('\udcbb' == yyC) ||
                (('\udcbd' <= yyC) && (yyC <= '\udcc3')) ||
                (('\udcc5' <= yyC) && (yyC <= '\udd05')) ||
                (('\udd07' <= yyC) && (yyC <= '\udd0a')) ||
                (('\udd0d' <= yyC) && (yyC <= '\udd14')) ||
                (('\udd16' <= yyC) && (yyC <= '\udd1c')) ||
                (('\udd1e' <= yyC) && (yyC <= '\udd39')) ||
                (('\udd3b' <= yyC) && (yyC <= '\udd3e')) ||
                (('\udd40' <= yyC) && (yyC <= '\udd44')) ||
                ('\udd46' == yyC) ||
                (('\udd4a' <= yyC) && (yyC <= '\udd50')) ||
                (('\udd52' <= yyC) && (yyC <= '\udea5')) ||
                (('\udea8' <= yyC) && (yyC <= '\udec0')) ||
                (('\udec2' <= yyC) && (yyC <= '\udeda')) ||
                (('\udedc' <= yyC) && (yyC <= '\udefa')) ||
                (('\udefc' <= yyC) && (yyC <= '\udf14')) ||
                (('\udf16' <= yyC) && (yyC <= '\udf34')) ||
                (('\udf36' <= yyC) && (yyC <= '\udf4e')) ||
                (('\udf50' <= yyC) && (yyC <= '\udf6e')) ||
                (('\udf70' <= yyC) && (yyC <= '\udf88')) ||
                (('\udf8a' <= yyC) && (yyC <= '\udfa8')) ||
                (('\udfaa' <= yyC) && (yyC <= '\udfc2')) ||
                (('\udfc4' <= yyC) && (yyC <= '\udfcb'))) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud840':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\uded6')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '\ud87e':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (('\udc00' <= yyC) && (yyC <= '\ude1d')) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '$':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pUnicodeEscapeSequence(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Whitespace.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhitespace(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    Result       yyPredResult;
    boolean      yyPredMatched;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Void         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u000b':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\u3000':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('\f' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\u00a0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\ufeff':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('-' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('>' == yyC) {

                  yyPredMatched = false;

                  yyPredResult = pSpace$$Choice1(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("whitespace expected", yyStart);
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 6.

    yyResult = pSingleLineComment$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pSingleLineCommentChar(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<String>(v$el$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<String> a2s = yyRepValue1.reverse();

        StringBuilder buf = new StringBuilder();
        buf.append(a1);
        for (String s : a2s.list()) buf.append(s);
        NodeFactory.commentLog(createSpan(yyStart,yyCount), buf.toString());

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Alternative 7.

    yyResult = pMultiLineCommentNoLB(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pLineTerminatorSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pMultiLineCommentChar(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for a1s.
          Pair<String> a1s = yyRepValue1.reverse();

          yyBase = yyRepetition1;
          yyC    = character(yyBase);
          if ('*' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyC = character(yyIndex);
            if ('/' == yyC) {
              yyIndex = yyIndex + 1;

              StringBuilder buf = new StringBuilder();
              buf.append("/*");
              for (String s : a1s.list()) buf.append(s);
              buf.append("*/");
              NodeFactory.commentLog(createSpan(yyStart,yyCount+1), buf.toString());

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"*/\" expected", yyBase);
            }
          } else {
            yyError = yyError.select("\"*/\" expected", yyBase);
          }
        } // End scope for a1s.
      }
    }

    // Done.
    yyError = yyError.select("whitespace expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pWhitespace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.s.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ps(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.delete.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdelete(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "delete");

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("delete expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("delete expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.typeof.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptypeof(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('y' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('o' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('f' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "typeof");

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("typeof expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("typeof expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.void.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvoid(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Op         yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('d' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = NodeFactory.makeOp(createSpan(yyStart, yyCount), "void");

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("void expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("void expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.break.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pbreak(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('e' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('k' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("break expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("break expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.case.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcase(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("case expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("case expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.catch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcatch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('h' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("catch expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("catch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.continue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pcontinue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('i' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('u' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('e' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("continue expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("continue expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.debugger.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdebugger(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('b' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('g' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('g' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('e' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('r' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("debugger expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("debugger expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.default.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdefault(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('f' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('u' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('t' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("default expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("default expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.do.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pdo(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('d' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("do expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("do expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pelse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("else expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("else expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.finally.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfinally(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('l' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('y' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyPredMatched = false;

                  yyPredResult = pidrest(yyIndex);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("finally expected", yyStart);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("finally expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.for.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfor(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("for expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("for expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.function.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfunction(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('n' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('c' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('t' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('o' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyC = character(yyIndex);
                  if ('n' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyPredMatched = false;

                    yyPredResult = pidrest(yyIndex);
                    if (yyPredResult.hasValue()) {

                      yyPredMatched = true;
                    }

                    if (! yyPredMatched) {

                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("function expected", yyStart);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("function expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.get.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pget(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('g' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("get expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("get expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.if.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pif(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('f' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("if expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.new.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnew(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('w' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("new expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("new expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.return.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result preturn(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('r' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('n' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("return expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("return expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.set.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pset(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('e' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("set expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("set expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.switch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pswitch(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('s' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('w' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('t' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('c' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('h' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("switch expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("switch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.this.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthis(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("this expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("this expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.throw.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pthrow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('w' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("throw expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("throw expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.try.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptry(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('y' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("try expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("try expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.var.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pvar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('v' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('r' == yyC) {
          yyIndex = yyIndex + 1;

          yyPredMatched = false;

          yyPredResult = pidrest(yyIndex);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("var expected", yyStart);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("var expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.while.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwhile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('h' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('i' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("while expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("while expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.with.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pwith(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('w' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('i' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('t' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('h' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("with expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("with expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.export.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pexport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('x' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("export expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("export expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pimport(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('m' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('p' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('o' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('r' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('t' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("import expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.nullL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pnullL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('n' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('u' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('l' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("null l expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("null l expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.true.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result ptrue(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('t' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('u' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("true expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("true expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.false.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfalse(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('a' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('s' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('e' == yyC) {
              yyIndex = yyIndex + 1;

              yyPredMatched = false;

              yyPredResult = pidrest(yyIndex);
              if (yyPredResult.hasValue()) {

                yyPredMatched = true;
              }

              if (! yyPredMatched) {

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("false expected", yyStart);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("false expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.in.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pin(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('i' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('n' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("in expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("in expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pmodule(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('m' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('o' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('d' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('u' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('l' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('e' == yyC) {
                yyIndex = yyIndex + 1;

                yyPredMatched = false;

                yyPredResult = pidrest(yyIndex);
                if (yyPredResult.hasValue()) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                } else {
                  yyError = yyError.select("module expected", yyStart);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("module expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.from.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pfrom(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('f' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('r' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('o' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('m' == yyC) {
            yyIndex = yyIndex + 1;

            yyPredMatched = false;

            yyPredResult = pidrest(yyIndex);
            if (yyPredResult.hasValue()) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("from expected", yyStart);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("from expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Keyword.as.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pas(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('s' == yyC) {
        yyIndex = yyIndex + 1;

        yyPredMatched = false;

        yyPredResult = pidrest(yyIndex);
        if (yyPredResult.hasValue()) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("as expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("as expected", yyStart);
    return yyError;
  }

  // =========================================================================

  Span createSpan(int start, int end) {
    int i = end;
    while ( i >= 0 && yyData.length > i && yyData[i] == ' ' ) { i--; }
    if ( i-1 >= start )
    end = i-1;
    else
    end = start;
    Column s = column(start);
    Column e = column(end);
    SourceLocRats slStart = new SourceLocRats(s.file, s.line, s.column, start);
    SourceLocRats slEnd   = new SourceLocRats(e.file, e.line, e.column, end);
    return new Span(slStart, slEnd);
  }
  
  private FileWriter fw;
  private BufferedWriter writer;
  private BufferedReader reader;
  private String logFile = column(0).file + ".log";
  private boolean keepComments = NodeUtil.getKeepComments();
  public Result JSmain(final int yyStart) throws IOException {
    NodeFactory.initComment();
    Result result = this.pJS$File(yyStart);
    if (result.hasValue()) return result;
    else {
      writer.close();
      fw.close();
      return result;
    }
  }
  
  void initParser() {
    try {
      kr.ac.kaist.jsaf.useful.Pair<FileWriter,BufferedWriter> pair = Useful.filenameToBufferedWriter( logFile );
      fw = pair.first();
      writer = pair.second();
    } catch (IOException error) {
      error("Creating a log file for the parser failed!");
    }
  }
  
  private void log(String message) {
    NodeUtil.log(writer, message);
  }
  
  private VarStmt makeArrayNumberLiteral(Span span1, Id name, Span span2) {
    try {
      List<Double> result = new ArrayList<Double>();
      writer.close();
      fw.close();
      FileReader fr = new FileReader(logFile);
      BufferedReader reader = new BufferedReader(fr);
      String line = reader.readLine();
      while (line != null) {
        Double number = NodeFactory.makeNumericLiteral(writer, span2, line);
        result.add(number);
        line = reader.readLine();
      }
      reader.close();
      fr.close();
      Expr expr = NodeFactory.makeArrayNumberExpr(span2, result);
      VarDecl vd = NodeFactory.makeVarDecl(span1, name, Option.<Expr>some(expr));
      initParser();
      return NodeFactory.makeVarStmt(span1, Useful.list(vd));
    } catch (IOException error) {
      error("Closing a log file for the parser failed!");
      return NodeFactory.makeVarStmt(span1, new ArrayList<VarDecl>());
    }
  }
  static {
    add(JAVASCRIPT_RESERVED, new String[] {
      "break",        "case",         "catch",        "continue",
      "debugger",     "default",      "delete",       "do",
      "else",         "finally",      "for",          "function",
      "if",           "in",           "instanceof",   "new",
      "return",       "switch",       "this",         "throw",
      "try",          "typeof",       "var",          "void",
      "while",        "with",
      
      /*
      "class",        "const",        "enum",         "export",
      "extends",      "import",       "super",
      
      "null",         "true",         "false"
      
      "module",       "from",         "as"
      */
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
