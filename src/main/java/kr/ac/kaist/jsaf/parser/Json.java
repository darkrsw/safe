// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.1,
// (C) 2004-2008 Robert Grimm,
// on Monday, October 24, 2016 at 5:42:32 PM.
// Edit at your own risk.
// ===========================================================================

package kr.ac.kaist.jsaf.parser;

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import kr.ac.kaist.jsaf.nodes.*;
import kr.ac.kaist.jsaf.nodes_util.*;
import kr.ac.kaist.jsaf.useful.Useful;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.jsaf.exceptions.JSAFError.error;

/**
 * Packrat parser for grammar <code>kr.ac.kaist.jsaf.parser.Json</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.1, (C) 2004-2008 Robert Grimm.
 */
public final class Json extends ParserBase {

  // =========================================================================

  /** Memoization table column. */
  static final class JsonColumn extends Column {
    Result finitParser;
    Result fJSONValue;
    Result fJSONObject;
    Result fJSONMember;
    Result fJSONString;
    Result fJSONString$$Star1;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Json(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Json(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new JsonColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONApp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJSONApp(final int yyStart) throws IOException {
    Result     yyResult;
    JSONValue  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinitParser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJSONObject(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEndOfFile(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONText.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJSONText(final int yyStart) throws IOException {
    Result     yyResult;
    JSONValue  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pinitParser(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pEndOfFile(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = JSONValue.nullV();

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pJSONValue(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyResult = pw(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pEndOfFile(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.initParser.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pinitParser(final int yyStart) throws IOException {
    JsonColumn yyColumn = (JsonColumn)column(yyStart);
    if (null == yyColumn.finitParser) 
      yyColumn.finitParser = pinitParser$1(yyStart);
    return yyColumn.finitParser;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.Json.initParser. */
  private Result pinitParser$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONValue(final int yyStart) throws IOException {
    JsonColumn yyColumn = (JsonColumn)column(yyStart);
    if (null == yyColumn.fJSONValue) 
      yyColumn.fJSONValue = pJSONValue$1(yyStart);
    return yyColumn.fJSONValue;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.Json.JSONValue. */
  private Result pJSONValue$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    JSONValue  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'n':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('u' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('l' == yyC) {

                      yyValue = JSONValue.nullV();

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyValue = JSONValue.trueV();

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyValue = JSONValue.falseV();

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyResult = pJSONObject(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pJSONArray(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pJSONString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = JSONValue.strF(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pJSONNumber(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = JSONValue.numF(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("j s o n value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONObject.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONObject(final int yyStart) throws IOException {
    JsonColumn yyColumn = (JsonColumn)column(yyStart);
    if (null == yyColumn.fJSONObject) 
      yyColumn.fJSONObject = pJSONObject$1(yyStart);
    return yyColumn.fJSONObject;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.Json.JSONObject. */
  private Result pJSONObject$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    JSONValue  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('{' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if ('}' == yyC) {
          yyIndex = yyChoice1 + 1;

          yyValue = JSONValue.objF(new ArrayList<kr.ac.kaist.jsaf.useful.Pair<String, JSONValue>>());

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"}\" expected", yyBase);
        }

        // Nested alternative 2.

        yyResult = pJSONMemberList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<kr.ac.kaist.jsaf.useful.Pair<String,JSONValue>> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if ('}' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = JSONValue.objF(a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"}\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("j s o n object expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONMemberList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONMemberList(final int yyStart) throws IOException {
    int                                                  yyC;
    int                                                  yyIndex;
    Result                                               yyResult;
    int                                                  yyBase;
    int                                                  yyRepetition1;
    Pair<kr.ac.kaist.jsaf.useful.Pair<String,JSONValue>> yyRepValue1;
    int                                                  yyOption1;
    List<kr.ac.kaist.jsaf.useful.Pair<String,JSONValue>> yyValue;
    ParseError                                           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJSONMember(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      kr.ac.kaist.jsaf.useful.Pair<String,JSONValue> a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyResult.index + 1;

            yyResult = pw(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pJSONMember(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                kr.ac.kaist.jsaf.useful.Pair<String,JSONValue> v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = 
                  new Pair<kr.ac.kaist.jsaf.useful.Pair<String,JSONValue>>(v$el$1, yyRepValue1);
                continue;
              }
            }
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<kr.ac.kaist.jsaf.useful.Pair<String,JSONValue>> a2s = yyRepValue1.reverse();

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyOption1 + 1;

            yyOption1  = yyIndex;
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new ArrayList<kr.ac.kaist.jsaf.useful.Pair<String, JSONValue>>();
            yyValue.add(a1);
            for (kr.ac.kaist.jsaf.useful.Pair<String, JSONValue> pair : a2s.list())
            yyValue.add(pair);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONMember.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONMember(final int yyStart) throws IOException {
    JsonColumn yyColumn = (JsonColumn)column(yyStart);
    if (null == yyColumn.fJSONMember) 
      yyColumn.fJSONMember = pJSONMember$1(yyStart);
    return yyColumn.fJSONMember;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.Json.JSONMember. */
  private Result pJSONMember$1(final int yyStart) throws IOException {
    int                                            yyC;
    int                                            yyIndex;
    Result                                         yyResult;
    int                                            yyBase;
    kr.ac.kaist.jsaf.useful.Pair<String,JSONValue> yyValue;
    ParseError                                     yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJSONString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyResult = pw(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if (':' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pw(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pJSONValue(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              JSONValue a2 = yyResult.semanticValue();

              yyValue = new kr.ac.kaist.jsaf.useful.Pair<String, JSONValue>(a1, a2);

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("\":\" expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONArray.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONArray(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    JSONValue  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pw(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase = yyChoice1;
        yyC    = character(yyBase);
        if (']' == yyC) {
          yyIndex = yyChoice1 + 1;

          yyValue = JSONValue.arrF(new ArrayList<JSONValue>());

          return new SemanticValue(yyValue, yyIndex, yyError);
        } else {
          yyError = yyError.select("\"]\" expected", yyBase);
        }

        // Nested alternative 2.

        yyResult = pJSONElementList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          List<JSONValue> a1 = yyResult.semanticValue();

          yyResult = pw(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyBase = yyResult.index;
            yyC    = character(yyBase);
            if (']' == yyC) {
              yyIndex = yyResult.index + 1;

              yyValue = JSONValue.arrF(a1);

              return new SemanticValue(yyValue, yyIndex, yyError);
            } else {
              yyError = yyError.select("\"]\" expected", yyBase);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("j s o n array expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONElementList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONElementList(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    int             yyBase;
    int             yyRepetition1;
    Pair<JSONValue> yyRepValue1;
    int             yyOption1;
    List<JSONValue> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJSONValue(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      JSONValue a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyResult.index + 1;

            yyResult = pw(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pJSONValue(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                JSONValue v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<JSONValue>(v$el$1, yyRepValue1);
                continue;
              }
            }
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }
        }
        break;
      }
      { // Start scope for a2s.
        Pair<JSONValue> a2s = yyRepValue1.reverse();

        yyResult = pw(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if (',' == yyC) {
            yyIndex = yyOption1 + 1;

            yyOption1  = yyIndex;
          } else {
            yyError = yyError.select("\",\" expected", yyBase);
          }

          yyResult = pw(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = new ArrayList<JSONValue>();
            yyValue.add(a1);
            yyValue.addAll(a2s.list());

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONString(final int yyStart) throws IOException {
    JsonColumn yyColumn = (JsonColumn)column(yyStart);
    if (null == yyColumn.fJSONString) 
      yyColumn.fJSONString = pJSONString$1(yyStart);
    return yyColumn.fJSONString;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.Json.JSONString. */
  private Result pJSONString$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pJSONString$$Star1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> a1s = yyResult.semanticValue();

        yyC = character(yyResult.index);
        if ('\"' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = "";
          for (String c : (List<String>)a1s.list()) yyValue = yyValue.concat(c);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("j s o n string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.Json.JSONString$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONString$$Star1(final int yyStart) throws IOException {
    JsonColumn yyColumn = (JsonColumn)column(yyStart);
    if (null == yyColumn.fJSONString$$Star1) 
      yyColumn.fJSONString$$Star1 = pJSONString$$Star1$1(yyStart);
    return yyColumn.fJSONString$$Star1;
  }

  /** Actually parse kr.ac.kaist.jsaf.parser.Json.JSONString$$Star1. */
  private Result pJSONString$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJSONStringCharacter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v$el$1 = yyResult.semanticValue();

      yyResult = pJSONString$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Pair<String> v$2 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONStringCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONStringCharacter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pJSONEscapeSequence(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyValue = a2;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pJSONStringCharacter$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = String.valueOf(a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("j s o n string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.Json.JSONStringCharacter$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONStringCharacter$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonJSONStringChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("j s o n string character expected", yyStart);
    }

    // Done.
    yyError = yyError.select("j s o n string character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONEscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONEscapeSequence(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJSONEscapeCharacter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pUnicodeEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONEscapeCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONEscapeCharacter(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('\"' == a1) ||
          ('/' == a1) ||
          ('\\' == a1) ||
          ('b' == a1) ||
          ('f' == a1) ||
          ('n' == a1) ||
          ('r' == a1) ||
          ('t' == a1)) {

        switch (a1) {
          case '"': { yyValue = "\\\""; break; }
          case '/': { yyValue = "/"; break; }
          case '\\': { yyValue = "\\\\"; break; }
          case 'b': { yyValue = "\\b"; break; }
          case 'f': { yyValue = "\\f"; break; }
          case 'n': { yyValue = "\\n"; break; }
          case 'r': { yyValue = "\\r"; break; }
          case 't': { yyValue = "\\t"; break; }
          default : { yyValue = ""; break; }
        }

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("j s o n escape character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.UnicodeEscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeEscapeSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pHexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pHexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyResult = pHexDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a4 = yyResult.semanticValue();

            yyResult = pHexDigit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a5 = yyResult.semanticValue();

              yyValue = "\\"+a1+a2+a3+a4+a5;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unicode escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.HexDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.NonJSONStringChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonJSONStringChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ((('\u0000' <= a1) && (a1 <= '\u001f')) ||
          ('\"' == a1) ||
          ('\\' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("non j s o n string char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONNumber.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONNumber(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('-' == yyC) {
      yyIndex = yyOption1 + 1;
      String v$el$1 = "-";

      yyOption1  = yyIndex;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("\"-\" expected", yyBase);
    }
    { // Start scope for a1.
      String a1 = yyOpValue1;

      yyResult = pw(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pDecimalIntegerLiteral(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJSONFraction(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for a3.
            String a3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExponentPart(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for a4.
              String a4 = yyOpValue1;

              if (a1 != null) yyValue = "-"+a2; else yyValue = a2;
              if (a3 != null) yyValue += a3;
              if (a4 != null) yyValue += a4;

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for a4.
          } // End scope for a3.
        }
      }
    } // End scope for a1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.DecimalIntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalIntegerLiteral(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = "0";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('1' <= a1) && (a1 <= '9')) {

        yyOption1  = yyIndex;
        yyOpValue1 = null;

        yyResult = pDecimalDigits(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for a2.
          String a2 = yyOpValue1;

          yyValue = a1+"";
          if (a2 != null) yyValue += a2;

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for a2.
      }
    }

    // Done.
    yyError = yyError.select("decimal integer literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.JSONFraction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJSONFraction(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pDecimalDigits(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a1 = yyResult.semanticValue();

        yyValue = "."+a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("j s o n fraction expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.DecimalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.ExponentPart.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentPart(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Character  yyOpValue1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;
          yyOpValue1 = null;

          yyResult = pExponentPart$$Choice1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Character v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for a1.
            Character a1 = yyOpValue1;

            yyResult = pDecimalDigits(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a2 = yyResult.semanticValue();

              if (a1 == null) yyValue = "e"+a2;
              else            yyValue = "e"+a1+a2;

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for a1.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.Json.ExponentPart$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponentPart$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('+' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("exponent part expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('\u001a' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    } else {
      yyError = yyError.select("\"\\u001a\" expected", yyBase);
    }

    yyResult = pw(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if (-1 != yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("end of file expected", yyStart);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.w.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pw(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyResult = pSpace(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.Json.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\t' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (' ' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================


}
