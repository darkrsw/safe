// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.1,
// (C) 2004-2008 Robert Grimm,
// on Monday, November 21, 2016 at 6:10:59 PM.
// Edit at your own risk.
// ===========================================================================

package kr.ac.kaist.jsaf.parser;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import kr.ac.kaist.jsaf.nodes.*;
import kr.ac.kaist.jsaf.nodes_util.*;
import kr.ac.kaist.jsaf.useful.Useful;
import edu.rice.cs.plt.tuple.Option;
import edu.rice.cs.plt.iter.IterUtil;
import edu.rice.cs.plt.collect.CollectUtil;
import xtc.util.Action;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import static kr.ac.kaist.jsaf.exceptions.JSAFError.error;

/**
 * Packrat parser for grammar <code>kr.ac.kaist.jsaf.parser.RegExp</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.1, (C) 2004-2008 Robert Grimm.
 */
public final class RegExp extends ParserBase {

  /** The JAVASCRIPT_RESERVED set. */
  public static final Set<String> JAVASCRIPT_RESERVED = new HashSet<String>();

  // =========================================================================

  /** Memoization table column. */
  static final class RegExpColumn extends Column {
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public RegExp(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public RegExp(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new RegExpColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Pattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pPattern(final int yyStart) throws IOException {
    Result        yyResult;
    RegExpPattern yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEndOfFile(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = new RegExpPattern(makeParenInfo(0), makeEmptyDisjunction());

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDisjunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpDisjunction a1 = yyResult.semanticValue();

      yyResult = pEndOfFile(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new RegExpPattern(makeParenInfo(getParenCount(a1)), a1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Disjunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDisjunction(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    RegExpDisjunction yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAlternative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpAlternative a1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('|' == yyC) {
        yyIndex = yyResult.index + 1;

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pDisjunction(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          RegExpDisjunction a2 = yyResult.semanticValue();

          yyValue = new RegExpConsDisjunction(makeParenInfo(getParenCount(a1) + getParenCount(a2)), a1, a2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new RegExpConsDisjunction(makeParenInfo(getParenCount(a1)), a1,
        new RegExpBaseDisjunction(makeParenInfo(0), new RegExpEmptyAlternative(makeParenInfo(0))));

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("\"|\" expected", yyBase);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pDisjunction(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        RegExpDisjunction a2 = yyResult.semanticValue();

        yyValue = new RegExpConsDisjunction(makeParenInfo(getParenCount(a2)), new RegExpEmptyAlternative(makeParenInfo(0)), a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pAlternative(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpAlternative a1 = yyResult.semanticValue();

      yyValue = new RegExpBaseDisjunction(makeParenInfo(getParenCount(a1)), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("disjunction expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Alternative.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAlternative(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Pair<RegExpTerm>  yyRepValue1;
    RegExpAlternative yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpTerm a1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTerm(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          RegExpTerm v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<RegExpTerm>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for a2s.
        Pair<RegExpTerm> a2s = yyRepValue1.reverse();

        List<RegExpTerm> l = new ArrayList<RegExpTerm>();
        l.add(a1);
        if (a2s != null) l.addAll(a2s.list());
        RegExpAlternative a = new RegExpConsAlternative(makeParenInfo(getParenCount(a1)), new RegExpEmptyAlternative(makeParenInfo(0)), a1);
        for (RegExpTerm t : a2s)
        a = new RegExpConsAlternative(makeParenInfo(getParenCount(a) + getParenCount(t)), a, t);
        yyValue = a;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for a2s.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    Result     yyResult;
    RegExpTerm yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssertion(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAtom(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpAtom a1 = yyResult.semanticValue();

      yyResult = pQuantifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        RegExpQuantifier a2 = yyResult.semanticValue();

        yyValue = new RegExpAtomQuantifier(makeParenInfo(getParenCount(a1) + getParenCount(a2)), a1, a2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pAtom(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Assertion.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssertion(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    int               yyOption1;
    RegExpDisjunction yyOpValue1;
    RegExpAssertion   yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '^':
        {
          yyValue = new RegExpAssertionCaret(makeParenInfo(0));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '$':
        {
          yyValue = new RegExpAssertionDollar(makeParenInfo(0));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case 'b':
              {
                yyValue = new RegExpAssertionLowerCaseB(makeParenInfo(0));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'B':
              {
                yyValue = new RegExpAssertionUpperCaseB(makeParenInfo(0));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '(':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('?' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case '=':
                  {
                    yyOption1  = yyIndex;
                    yyOpValue1 = null;

                    yyResult = pDisjunction(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      RegExpDisjunction v$el$1 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$1;
                    }
                    { // Start scope for a1.
                      RegExpDisjunction a1 = yyOpValue1;

                      yyBase = yyOption1;
                      yyC    = character(yyBase);
                      if (')' == yyC) {
                        yyIndex = yyOption1 + 1;

                        if (a1 == null)
                        a1 = makeEmptyDisjunction();
                        yyValue = new RegExpAssertionEqual(makeParenInfo(getParenCount(a1)), a1);

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("\")\" expected", yyBase);
                      }
                    } // End scope for a1.
                  }
                  break;

                case '!':
                  {
                    yyOption1  = yyIndex;
                    yyOpValue1 = null;

                    yyResult = pDisjunction(yyOption1);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      RegExpDisjunction v$el$2 = yyResult.semanticValue();

                      yyOption1  = yyResult.index;
                      yyOpValue1 = v$el$2;
                    }
                    { // Start scope for a1.
                      RegExpDisjunction a1 = yyOpValue1;

                      yyBase = yyOption1;
                      yyC    = character(yyBase);
                      if (')' == yyC) {
                        yyIndex = yyOption1 + 1;

                        if (a1 == null)
                        a1 = makeEmptyDisjunction();
                        yyValue = new RegExpAssertionExcla(makeParenInfo(getParenCount(a1)), a1);

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      } else {
                        yyError = yyError.select("\")\" expected", yyBase);
                      }
                    } // End scope for a1.
                  }
                  break;

                default:
                  /* No match. */
                }
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("assertion expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Atom.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAtom(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    int               yyBase;
    int               yyOption1;
    RegExpDisjunction yyOpValue1;
    RegExpAtom        yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatternCharacter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '.':
        {
          yyValue = new RegExpDot(makeParenInfo(0));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyResult = pAtomEscape(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            RegExpAtomEscape a1 = yyResult.semanticValue();

            yyValue = a1;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyResult = pCharacterClass(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpCharacterClass a1 = yyResult.semanticValue();

      yyValue = a1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('(' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pDisjunction(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          RegExpDisjunction v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for a1.
          RegExpDisjunction a1 = yyOpValue1;

          yyBase = yyOption1;
          yyC    = character(yyBase);
          if (')' == yyC) {
            yyIndex = yyOption1 + 1;

            if (a1 == null) a1 = makeEmptyDisjunction();
            yyValue = new RegExpParen(makeParenInfo(getParenCount(a1) + 1), a1);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\")\" expected", yyBase);
          }
        } // End scope for a1.

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;
          if ('?' == yyC) {

            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if (':' == yyC) {

                yyOption1  = yyIndex;
                yyOpValue1 = null;

                yyResult = pDisjunction(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  RegExpDisjunction v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
                { // Start scope for a1.
                  RegExpDisjunction a1 = yyOpValue1;

                  yyBase = yyOption1;
                  yyC    = character(yyBase);
                  if (')' == yyC) {
                    yyIndex = yyOption1 + 1;

                    if (a1 == null) a1 = makeEmptyDisjunction();
                    yyValue = new RegExpParenOpt(makeParenInfo(getParenCount(a1)), a1);

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  } else {
                    yyError = yyError.select("\")\" expected", yyBase);
                  }
                } // End scope for a1.
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("atom expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.PatternCharacter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternCharacter(final int yyStart) throws IOException {
    Result            yyResult;
    RegExpPatternChar yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatternCharacter$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = new RegExpPatternChar(makeParenInfo(0), a1+"");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.RegExp.PatternCharacter$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternCharacter$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonPatternChar(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("pattern character expected", yyStart);
    }

    // Done.
    yyError = yyError.select("pattern character expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.NonPatternChar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonPatternChar(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('$' == a1) ||
          (('(' <= a1) && (a1 <= '+')) ||
          ('.' == a1) ||
          ('?' == a1) ||
          ('\\' == a1) ||
          ('^' == a1) ||
          ('|' == a1)) {

        yyValue = a1+"";

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('[' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = "[";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("non pattern char expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.AtomEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAtomEscape(final int yyStart) throws IOException {
    Result           yyResult;
    RegExpAtomEscape yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCharacterEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pCharacterClassEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.CharacterEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterEscape(final int yyStart) throws IOException {
    int                   yyC;
    int                   yyIndex;
    Result                yyResult;
    RegExpCharacterEscape yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pControlEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('c' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pControlLetter(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        RegExpControlLetter a1 = yyResult.semanticValue();

        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pHexEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new RegExpHexEscapeSequence(makeParenInfo(0), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pUnicodeEscapeSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyValue = new RegExpUnicodeEscapeSequence(makeParenInfo(0), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pIdentityEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("character escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.ControlEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pControlEscape(final int yyStart) throws IOException {
    int                 yyC;
    int                 yyIndex;
    RegExpControlEscape yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('f' == a1) ||
          ('n' == a1) ||
          ('r' == a1) ||
          ('t' == a1) ||
          ('v' == a1)) {

        yyValue = new RegExpControlEscape(makeParenInfo(0), a1+"");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("control escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.ControlLetter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pControlLetter(final int yyStart) throws IOException {
    int                 yyC;
    int                 yyIndex;
    RegExpControlLetter yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if ((('A' <= a1) && (a1 <= 'Z')) ||
          (('a' <= a1) && (a1 <= 'z'))) {

        yyValue = new RegExpControlLetter(makeParenInfo(0), a1+"");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("control letter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.IdentityEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentityEscape(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    RegExpIdentityEscape yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('_' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyValue = new RegExpIdentityEscape(makeParenInfo(0), a1+"");

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyResult = pIdentityEscape$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = new RegExpIdentityEscape(makeParenInfo(0), a1+"");

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIdentityEscape$$Choice2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = new RegExpIdentityEscape(makeParenInfo(0), a1+"");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("identity escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.RegExp.IdentityEscape$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentityEscape$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pidrest(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("identity escape expected", yyStart);
    }

    // Done.
    yyError = yyError.select("identity escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.RegExp.IdentityEscape$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentityEscape$$Choice2(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\u200c' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('\u200d' == yyC) {
      yyIndex = yyStart + 1;
      yyValue = Character.valueOf((char)yyC);

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("identity escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.DecimalEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalEscape(final int yyStart) throws IOException {
    int                 yyC;
    int                 yyIndex;
    Result              yyResult;
    boolean             yyPredMatched;
    int                 yyOption1;
    String              yyOpValue1;
    RegExpDecimalEscape yyValue;
    ParseError          yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyPredMatched = false;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        if (('0' <= yyC) && (yyC <= '9')) {

          yyPredMatched = true;
        }
      }

      if (! yyPredMatched) {

        yyValue = new RegExpDecimalEscape(makeParenInfo(0), "0");

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("decimal escape expected", yyStart);
      }
    }

    // Alternative 2.

    yyResult = pNonZeroDigit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String a1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDecimalDigits(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for a2.
        String a2 = yyOpValue1;

        yyPredMatched = false;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          if (('0' <= yyC) && (yyC <= '9')) {

            yyPredMatched = true;
          }
        }

        if (! yyPredMatched) {

          if (a2 == null) yyValue = new RegExpDecimalEscape(makeParenInfo(0), a1);
          else yyValue = new RegExpDecimalEscape(makeParenInfo(0), a1+a2);

          return new SemanticValue(yyValue, yyOption1, yyError);
        } else {
          yyError = yyError.select("decimal escape expected", yyStart);
        }
      } // End scope for a2.
    }

    // Done.
    yyError = yyError.select("decimal escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.NonZeroDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonZeroDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("non zero digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.DecimalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.CharacterClassEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterClassEscape(final int yyStart) throws IOException {
    int                        yyC;
    int                        yyIndex;
    RegExpCharacterClassEscape yyValue;
    ParseError                 yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      if (('D' == a1) ||
          ('S' == a1) ||
          ('W' == a1) ||
          ('d' == a1) ||
          ('s' == a1) ||
          ('w' == a1)) {

        yyValue = new RegExpCharacterClassEscape(makeParenInfo(0), a1+"");

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("character class escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.CharacterClass.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterClass(final int yyStart) throws IOException {
    int                  yyC;
    int                  yyIndex;
    Result               yyResult;
    int                  yyBase;
    RegExpCharacterClass yyValue;
    ParseError           yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ('[' == yyC) {

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;
          if ('^' == yyC) {

            yyResult = pClassRanges(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              RegExpClassRanges a1 = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if (']' == yyC) {
                yyIndex = yyResult.index + 1;

                yyValue = new RegExpCharacterClassExclusion(makeParenInfo(0), a1);

                return new SemanticValue(yyValue, yyIndex, yyError);
              } else {
                yyError = yyError.select("\"]\" expected", yyBase);
              }
            }
          }
        }

        // Nested alternative 2.

        yyResult = pNoCaretClassRanges(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          RegExpClassRanges a1 = yyResult.semanticValue();

          yyBase = yyResult.index;
          yyC    = character(yyBase);
          if (']' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = new RegExpCharacterClassInclusion(makeParenInfo(0), a1);

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("\"]\" expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("character class expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.ClassRanges.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassRanges(final int yyStart) throws IOException {
    Result                    yyResult;
    int                       yyOption1;
    RegExpNonemptyClassRanges yyOpValue1;
    RegExpClassRanges         yyValue;
    ParseError                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pNonemptyClassRanges(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpNonemptyClassRanges v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for yyValue.
      yyValue = yyOpValue1;

      if (yyValue == null) yyValue = new RegExpEmptyClassRanges(new RegExpClassRangesInfo(true));

      return new SemanticValue(yyValue, yyOption1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.NoCaretClassRanges.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNoCaretClassRanges(final int yyStart) throws IOException {
    Result            yyResult;
    RegExpClassRanges yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pClassRanges(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpClassRanges a1 = yyResult.semanticValue();

      if (((RegExpClassRangesInfo) a1.getInfo()).isNoCaret()) {

        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("no caret class ranges expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.NonemptyClassRanges.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonemptyClassRanges(final int yyStart) throws IOException {
    int                       yyC;
    int                       yyIndex;
    Result                    yyResult;
    int                       yyBase;
    RegExpNonemptyClassRanges yyValue;
    ParseError                yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharacterClassEscape(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        RegExpCharacterClassEscape a1 = yyResult.semanticValue();

        yyResult = pNonemptyClassRanges(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          RegExpNonemptyClassRanges a2 = yyResult.semanticValue();

          RegExpClassRangesInfo info = new RegExpClassRangesInfo(true);
          yyValue = new RegExpNonemptyClassRangesAtoms(new RegExpClassRangesInfo(true),
          new RegExpClassCharacterClassEscape(info, a1), a2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pClassAtom(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpClassAtom a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('-' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pClassAtom(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          RegExpClassAtom a2 = yyResult.semanticValue();

          yyResult = pClassRanges(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            RegExpClassRanges a3 = yyResult.semanticValue();

            yyValue = new RegExpNonemptyClassRangesDash(new RegExpClassRangesInfo(((RegExpClassRangesInfo) a1.getInfo()).isNoCaret()), a1, a2, a3);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("\"-\" expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pNonemptyClassRanges(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        RegExpNonemptyClassRanges a2 = yyResult.semanticValue();

        yyValue = new RegExpNonemptyClassRangesAtoms(new RegExpClassRangesInfo(((RegExpClassRangesInfo) a1.getInfo()).isNoCaret()), a1, a2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyValue = new RegExpNonemptyClassRangesAtom(new RegExpClassRangesInfo(((RegExpClassRangesInfo) a1.getInfo()).isNoCaret()), a1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select("nonempty class ranges expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.ClassAtom.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassAtom(final int yyStart) throws IOException {
    int             yyC;
    int             yyIndex;
    Result          yyResult;
    RegExpClassAtom yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = new RegExpClassAtomDash(new RegExpClassRangesInfo(true));

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyResult = pClassAtomNoDash(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("class atom expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.ClassAtomNoDash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassAtomNoDash(final int yyStart) throws IOException {
    int                   yyC;
    int                   yyIndex;
    Result                yyResult;
    RegExpClassAtomNoDash yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pClassEscape(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        RegExpClassEscape a1 = yyResult.semanticValue();

        yyValue = a1;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pClassAtomNoDash$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Character a1 = yyResult.semanticValue();

      yyValue = new RegExpClassAtomNoDashCharacter(new RegExpClassRangesInfo(a1 != '^'), a1+"");

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("class atom no dash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * kr.ac.kaist.jsaf.parser.RegExp.ClassAtomNoDash$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassAtomNoDash$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Character  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyPredResult = pNonClassAtomNoDash(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;
        yyValue = Character.valueOf((char)yyC);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("class atom no dash expected", yyStart);
    }

    // Done.
    yyError = yyError.select("class atom no dash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.NonClassAtomNoDash.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNonClassAtomNoDash(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyValue = a1+"";

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "-";

      yyValue = a1;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (']' == yyC) {
      yyIndex = yyStart + 1;
      String a1 = "]";

      yyValue = a1;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("non class atom no dash expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.ClassEscape.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassEscape(final int yyStart) throws IOException {
    int               yyC;
    int               yyIndex;
    Result            yyResult;
    RegExpClassEscape yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpDecimalEscape a1 = yyResult.semanticValue();

      yyValue = new RegExpClassDecimalEscape(new RegExpClassRangesInfo(true), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('b' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = new RegExpClassEscapeB(new RegExpClassRangesInfo(true));

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 3.

    yyResult = pCharacterEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpCharacterEscape a1 = yyResult.semanticValue();

      yyValue = new RegExpClassCharacterEscape(new RegExpClassRangesInfo(true), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pCharacterClassEscape(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpCharacterClassEscape a1 = yyResult.semanticValue();

      yyValue = new RegExpClassCharacterClassEscape(new RegExpClassRangesInfo(true), a1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("class escape expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.HexEscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexEscapeSequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('x' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pHexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pHexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyValue = a1+a2+a3;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("hex escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.HexDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.UnicodeEscapeSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnicodeEscapeSequence(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('u' == yyC) {
      yyIndex = yyStart + 1;
      char a1 = (char)yyC;

      yyResult = pHexDigit(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        String a2 = yyResult.semanticValue();

        yyResult = pHexDigit(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String a3 = yyResult.semanticValue();

          yyResult = pHexDigit(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a4 = yyResult.semanticValue();

            yyResult = pHexDigit(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              String a5 = yyResult.semanticValue();

              yyValue = a1+a2+a3+a4+a5;

              return yyResult.createValue(yyValue, yyError);
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("unicode escape sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.Quantifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQuantifier(final int yyStart) throws IOException {
    int              yyC;
    int              yyIndex;
    Result           yyResult;
    int              yyBase;
    RegExpQuantifier yyValue;
    ParseError       yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pQuantifierPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RegExpQuantifierPrefix a1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase = yyChoice1;
      yyC    = character(yyBase);
      if ('?' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyValue = new RegExpQuantifier(makeParenInfo(0), a1, false);

        return new SemanticValue(yyValue, yyIndex, yyError);
      } else {
        yyError = yyError.select("\"?\" expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = new RegExpQuantifier(makeParenInfo(0), a1, true);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.QuantifierPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQuantifierPrefix(final int yyStart) throws IOException {
    int                    yyC;
    int                    yyIndex;
    Result                 yyResult;
    int                    yyBase;
    RegExpQuantifierPrefix yyValue;
    ParseError             yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyValue = new RegExpQuantifierStar(makeParenInfo(0));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '+':
        {
          yyValue = new RegExpQuantifierPlus(makeParenInfo(0));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = new RegExpQuantifierQuest(makeParenInfo(0));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyResult = pDecimalDigits(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            String a1 = yyResult.semanticValue();

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              switch (yyC) {
              case ',':
                {
                  final int yyChoice2 = yyIndex;

                  // Nested alternative 1.

                  yyResult = pDecimalDigits(yyChoice2);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    String a2 = yyResult.semanticValue();

                    yyBase = yyResult.index;
                    yyC    = character(yyBase);
                    if ('}' == yyC) {
                      yyIndex = yyResult.index + 1;

                      yyValue = new RegExpQuantifierNumber(makeParenInfo(0), new Integer(a1),
                      Option.<Integer>some(new Integer(a2)));

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    } else {
                      yyError = yyError.select("\"}\" expected", yyBase);
                    }
                  }

                  // Nested alternative 2.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;
                    if ('}' == yyC) {

                      yyValue = new RegExpQuantifierNumber(makeParenInfo(0), new Integer(a1), Option.<Integer>none());

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }
                  }
                }
                break;

              case '}':
                {
                  yyValue = new RegExpQuantifierNumber(makeParenInfo(0), new Integer(a1), Option.<Integer>some(new Integer(a1)));

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }

              default:
                /* No match. */
              }
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("quantifier prefix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.idrest.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pidrest(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("idrest expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal kr.ac.kaist.jsaf.parser.RegExp.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase = yyOption1;
    yyC    = character(yyBase);
    if ('\u001a' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    } else {
      yyError = yyError.select("\"\\u001a\" expected", yyBase);
    }

    yyPredMatched = false;

    yyC = character(yyOption1);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyOption1, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(JAVASCRIPT_RESERVED, new String[] {
      "break",        "catch",        "else",         "finally",
      "function",     "if",           "new",          "return",
      "then",         "throw",        "try",          "var",
      "while",        "with",
      
      "eval",         "false",        "get",          "null",
      "set",          "true",         "undefined"
    });
  }
  
  int getParenCount(RegExpAbstractNode node) {
    if (node.getInfo() instanceof RegExpCapturingParensInfo) {
      return ((RegExpCapturingParensInfo) node.getInfo()).getParenCount();
    } else {
      return 0;
    }
  }
  RegExpCapturingParensInfo makeParenInfo(int parenCount) {
    return new RegExpCapturingParensInfo(parenCount);
  }
  RegExpDisjunction makeEmptyDisjunction() {
    return new RegExpBaseDisjunction(makeParenInfo(0), new RegExpEmptyAlternative(makeParenInfo(0)));
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
